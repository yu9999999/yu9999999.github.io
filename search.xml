<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>两轮差速运动学</title>
      <link href="/2023/12/05/%E4%B8%A4%E8%BD%AE%E5%B7%AE%E9%80%9F%E8%BF%90%E5%8A%A8%E5%AD%A6/"/>
      <url>/2023/12/05/%E4%B8%A4%E8%BD%AE%E5%B7%AE%E9%80%9F%E8%BF%90%E5%8A%A8%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<p><strong>小知识：</strong><br />因为圆周弧长公式为：弧长=半径<em>角度<br />所以在同一时刻t下：线速度=半径</em>角速度（线速度也就是机器人行驶路径/时间，也就是弧长/t）</p><p><strong>定义符号：</strong> 左轮速度vL，右轮速度vR，线速度v，角速度w，R为两轮中心运动半径，H为两轮距离。<br />已知机器人左右轮速，推导其线速度与角速度：<br />1.vL=vR时: 机器人作直线运动，此时没有角速度，v=vL=vR。画个图一目了然，不解释<br />2.vL!=vR时：<br />（1）当vL与vR为同方向时， 机器人做圆周运动 （圆弧运动），此时有w=vR/(R+H/2)=vL/(R-H/2)=v/R<br />（2）当vL、vR异号或其中一个为零时，此时R=H/2: 差动机器人作绕自身中心的自转(因为力矩中心位于机器人两轮中心)，机器人中处的线速度为零，其角速度为：w=2(vR-vL)/H，还是用小知识推导</p><p>现在只考虑机器人做圆周运动的情形，特殊情况参考以上公式：<br />通过左右轮速度求解v、w称为正运动学：<br />w=(vR-vL)/H<br />v=w*R=(vR+vL)/2<br />R=H(vR+vL)/(2vR-2vL)</p><p>通过v、w求解左右轮速度称为逆运动学：<br />vR=(R+H/2)w<br />vL=(R-H/2)w<br />R=v/w</p><p>探讨：如果已知同一坐标下两点位姿，如何求线速度与角速度？（这个一般用于规划好路径后再求速度，比如Teb，但是源码好像有点问题，线速度直接用两点距离dist去求了，应该用dist = fabs(angle_diff * dist/(2*sin(angle_diff/2)))更新为弧长距离）<br />已知两点位姿可以求出两点距离与角度，然后可以求出半径，然后再求出弧长，最后线速度与角速度都可以求出，然后转成左右轮速度发布下去，剩下的交给电机。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Teb原理与源码</title>
      <link href="/2023/11/29/Teb%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81/"/>
      <url>/2023/11/29/Teb%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p><strong>原理：</strong> 这里是结合源码进行讲解的，用于局部路径规划，从数学角度也就是一个多目标最优化问题，通过设计代价函数（损失函数），然后求出最小代价值，获取最优的路径点，从而得到相应的速度。<br />1.从全局规划中获取局部路径点（也就是对路径点增删操作），这里暂且将这些点的位姿与时间作为向量变量，假设为x，将获取的局部路径点作为初始值x0<br />2.设置代价函数。在没有对路径点进行操作时，其路径代价函数可能是fpath(x0)=0（优化后的全局路径点没改变的化），其余的还有障碍物代价函数、速度、加速度、运动学、最短路径等代价函数。源码上的代价函数稍后简单介绍一下。<br />3.最后就是最小化代价函数，通过迭代找到最小代价值与其的对应的最优值x，此时x包含着位姿和时间，将这些点最为轨迹点，形成一条轨迹，也就是规划的行驶路线<br />4.通过两点位姿可以计算出对应的速度（线速度与角速度）<br />5.最后发布速度<br />注意：这里再求最优轨迹点时，用的是g2o库，其原理也就是迭代法，具体选择高斯牛顿法还是LM法，看自己需求。同时提一嘴，g2o也可以用于建图。在g2o中，顶点就是一些变量（路径点姿态，时间，移动障碍物等），如果1个误差函数与5个顶点相关，则连接5个顶点到误差函数形成5条边，然后设置好权重（一般误差函数是几维，权重就是几维对角阵），最后就是求最小误差函数（这个就是g2o自动去计算了）。再提一嘴，迭代法应用十分广泛，机器学习、深度学习很多原理都会用到，原理都十分简单。由于计算机性能问题，目前能求二阶导，也就是Hessian 矩阵已经不得了了，常见的还是雅可比矩阵。所以对数学来说相对简单，很少涉及到高阶求导，只是还需仔细阅读源码。</p><p><strong>teb代价函数计算：</strong> 误差*权重<br />1.障碍物代价值：首先判断是否进行了障碍物膨胀，之后定义了一个创建边的函数，如下所示，障碍物边是名为EdgeObstacle的类。之后，遍历每一个坐标点，找到离坐标点距离小于阈值的障碍物，以及左侧和右侧最近的障碍物，构建EdgeObstacle对象，作为图的障碍物边。边误差的计算为，当障碍物距离大于参数min_obstacle_dist时，都返回penalty_epsilon（相当于0）；反之返回与min_obstacle_dist距离差。这个计算公式有点像Relu激活函数。<br />2.via_point代价值：首先遍历每一个路径点，计算与当前路径点最近的全局路径坐标点，构建路径点边，边的误差计算就是欧氏距离。<br />3.速度代价值：这里进行一个处理，通过两点位姿可以计算两点距离与角度，从而求得弧长，从而获得线速度与角速度。边的误差计算就是与最大后退速度，最大x速度，最大角速度进行对比，在阈值内代价值为0，反之为其差。目的是防止线速度和角速度超过给定阈值。<br />4.加速度：与速度一样，保持在阈值内。<br />5.时间：其代价值就是时间大小，时间越大代价值也就越大。<br />6.最短化边：也就是两点距离，距离越小值越小。<br />7.运动学：第一个误差函数是(cos(t1)+cos(t2)-sin(t1)-sin(t2))*两点距离，在差动机器人中第二个误差函数是计算旋转误差（机器人位姿旋转到两点方向），小于90度误差为0，大于90度越大计算出的误差也就越大，如果该权重设大，说明最好前向移动</p><p><strong>teb与dwa原理对比：</strong><br />teb是先将全局路径点作为初始轨迹点，然后通过最小化代价值（这些代价值是与全局路径点、障碍物等有关的），通过g2o找到最优路径点，然后再去计算相应速度作为规划速度将其发布下去<br />dwa是先将速度区间通过样本数划分多个速度样本，然后将每个速度样本*t得出一条轨迹，再去将轨迹与全局路径、障碍物这些进行计算，也算是计算代价值，然后找到最小代价值对应的速度样本，将其作为规划速度发不下去</p>]]></content>
      
      
      <categories>
          
          <category> 机器人路径规划算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Teb </tag>
            
            <tag> 局部路径规划算法 </tag>
            
            <tag> ROS </tag>
            
            <tag> 机器人 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++</title>
      <link href="/2023/11/10/C-%E5%85%AC%E6%9C%89%E3%80%81%E7%A7%81%E6%9C%89%E4%B8%8E%E4%BF%9D%E6%8A%A4/"/>
      <url>/2023/11/10/C-%E5%85%AC%E6%9C%89%E3%80%81%E7%A7%81%E6%9C%89%E4%B8%8E%E4%BF%9D%E6%8A%A4/</url>
      
        <content type="html"><![CDATA[<p><strong>类：</strong> 由数据成员（属性）和成员函数（方法）组成。数据成员是描述类的属性的一些数据，成员函数是描述类的行为的一些数据。比如人类，每个人都有自己的姓名、年龄、出生日期、体重等, 为人类的属性部分, 此外, 人能够吃饭、睡觉、行走、说话等属于人类所具有的行为。<br /><strong>类的访问权限：</strong> 公有（public）、私有（private）和保护（protected），能不能访问直白的说就是，你可不可以去使用类中成员（某个函数或者数据）<br /><strong>公有成员：</strong> 类内和类外都可访问。<br /><strong>私有成员：</strong> 类内可访问（个人认为只能被本类中的成员函数访问），类外不可访问。友元可访问。<br /><strong>保护成员：</strong> 类内可访问，类外不可访问。友元可访问。但是派生类可以访问（派生类可以当作类外的一种特殊形式，不在类内但是与该类有关联）。<br /><strong>友元：</strong> 友元可以是一个函数，该函数称为友元函数。友元也可以是一个类，该类被称为友元类。比如在A类里声明一个友元函数B或者友元类B，那么该函数B或者类B就可以访问类A里面的所有成员）<br /><strong>继承：</strong> 当创建一个类时，不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类（父类），新建的类称为派生类（子类）。例如：哺乳动物是动物，狗是哺乳动物，因此，狗是动物。狗是哺乳动物的派生类，动物是哺乳动物的基类。</p><table><thead><tr><th style="text-align:center">访问</th><th style="text-align:center">public</th><th style="text-align:center">protected</th><th style="text-align:center">private</th></tr></thead><tbody><tr><td style="text-align:center">同一个类</td><td style="text-align:center">yes</td><td style="text-align:center">yes</td><td style="text-align:center">yes</td></tr><tr><td style="text-align:center">派生类</td><td style="text-align:center">yes</td><td style="text-align:center">yes</td><td style="text-align:center">no</td></tr><tr><td style="text-align:center">外部的类</td><td style="text-align:center">yes</td><td style="text-align:center">no</td><td style="text-align:center">no</td></tr></tbody></table><p>举个例子：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class A         </span><br><span class="line">&#123;</span><br><span class="line">    friend class B;</span><br><span class="line">public: </span><br><span class="line">    void <span class="function"><span class="title">print</span></span>() &#123;cout&lt;&lt; <span class="string">x &lt;&lt;endl;&#125;</span></span><br><span class="line"><span class="string">protected:</span></span><br><span class="line"><span class="string">    int y;</span></span><br><span class="line"><span class="string">    int getnum(int i) &#123;</span></span><br><span class="line"><span class="string">        x</span> += i; </span><br><span class="line">        <span class="built_in">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">private: </span><br><span class="line">    int x; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B         </span><br><span class="line">&#123;</span><br><span class="line">public: </span><br><span class="line">    void <span class="built_in">set</span>(int i)&#123;a.x = i;&#125;    //友元访问私有</span><br><span class="line">    void <span class="function"><span class="title">getnum</span></span>()&#123;a.getnum(2);&#125;  //友元访问保护</span><br><span class="line">    void <span class="function"><span class="title">print</span></span>()&#123;a.print();&#125;    //访问公有</span><br><span class="line">protected: </span><br><span class="line">    //这里只能由B类的成员访问，除非B作为其余类的基类，或者友元</span><br><span class="line">private: </span><br><span class="line">    A a;   //这里由于B为A的友元，所以可以访问A类所有成员。</span><br><span class="line">    int z;  //只能由B类的成员访问，除非B作为友元在其他类声明</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class C : public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void <span class="function"><span class="title">func</span></span>()&#123;y = 6;&#125;      //继承访问保护</span><br><span class="line">    //void <span class="function"><span class="title">func1</span></span>()&#123;x = 2;&#125;    //这是不可以的，继承不能访问私有</span><br><span class="line">protected: </span><br><span class="line">    //这里只能由C类的成员访问，除非C作为其余类的基类，或者友元</span><br><span class="line">private: </span><br><span class="line">    int m;  //只能由C类的成员访问，除非B作为友元在其他类声明</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>() </span><br><span class="line">&#123; </span><br><span class="line">    B b;</span><br><span class="line">    b.set(5);     //在类外访问公有函数<span class="built_in">set</span>，其余的公有函数都可以访问，注意这里是类外，不能访问保护和私有</span><br><span class="line">    b.getnum();   </span><br><span class="line">    b.print();  </span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指针的理解：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">void <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    int a = 10; </span><br><span class="line">    int *b ;</span><br><span class="line">    b = &amp;a;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a的地址：&quot;</span> &lt;&lt; &amp;a &lt;&lt; <span class="string">&quot; a的值：&quot;</span> &lt;&lt; <span class="string">a &lt;&lt; endl</span></span><br><span class="line"><span class="string">    &lt;&lt; &quot;指针b的值：&quot; &lt;&lt; b &lt;&lt; &quot; 指针b解地址：&quot; &lt;&lt; *b &lt;&lt; endl</span></span><br><span class="line"><span class="string">    &lt;&lt; &quot; 指针b的地址：&quot; &lt;&lt; &amp;b &lt;&lt; endl;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">//我的电脑输出：</span></span><br><span class="line"><span class="string">a</span>的地址：0000001688BFFBD4    a的值：10</span><br><span class="line">b的值：0000001688BFFBD4  指针b的解地址：10</span><br><span class="line">指针b的地址：0000001688BFFBF8</span><br><span class="line">//这样解释很明显了吧，</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法的理解</title>
      <link href="/2023/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2023/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> 数据结构</h1><p><strong>逻辑结构：</strong> 指数据元素之间逻辑关系的数据结构，这里的逻辑关系是指数据元素之间的前后间关系，与数据在计算机中的存储位置无关。<br /><strong>物理结构：</strong> 指数据的逻辑结构在计算机存储空间中的存放形式称为数据的物理结构，也叫做存储结构。</p><h2 id="逻辑结构"><a class="markdownIt-Anchor" href="#逻辑结构"></a> 逻辑结构：</h2><p><strong>线性结构：</strong> 数据元素之间存在“一对一”的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的，线性结构是一个有序数据元素的集合。比如：一维数组、队列、链表、栈。<br /><strong>非线性结构：</strong> 数据元素之间是一对多、多对一、多对多的关系。比如：树、堆、图、多维数组（相当于矩阵）。</p><h2 id="物理结构"><a class="markdownIt-Anchor" href="#物理结构"></a> 物理结构：</h2><p><strong>顺序存储：</strong> 用一组连续的存储单元依次存储数据元素，数据元素之间的逻辑关系由元素的存储位置来表示。比如：数组<br />例子：(bat,cat,eat,……,mat)<br />存储：</p><table><thead><tr><th style="text-align:center">…</th></tr></thead><tbody><tr><td style="text-align:center">bat</td></tr><tr><td style="text-align:center">cat</td></tr><tr><td style="text-align:center">eat</td></tr><tr><td style="text-align:center">…</td></tr></tbody></table><p><strong>链式存储：</strong> 用一组任意的储存单元储存数据元素，数据元素之间的逻辑关系用指针来表示。<br />例子：(bat,cat,eat,……,mat)<br />存储：</p><table><thead><tr><th style="text-align:center">元素索引</th><th style="text-align:center">元素</th><th style="text-align:center">下一个元素位置索引</th></tr></thead><tbody><tr><td style="text-align:center">130</td><td style="text-align:center">cat</td><td style="text-align:center">135</td></tr><tr><td style="text-align:center">135</td><td style="text-align:center">eat</td><td style="text-align:center">170</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td></tr><tr><td style="text-align:center">头指针head-&gt; 165</td><td style="text-align:center">bat</td><td style="text-align:center">130 -&gt;下个元素在130号，130单元找到cat</td></tr><tr><td style="text-align:center">170</td><td style="text-align:center">mat</td><td style="text-align:center">Null -&gt;最后一个元素下一个元素没有了为空</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td></tr></tbody></table><p><strong>索引存储：</strong> 在储存结点信息同时，还建立附加的索引表。比如手机通讯录，我们可以在手机通讯录上找到一个人名（这里人名就是索引index），点开这个人名，里面就会出现这个人的详细信息（这些信息就是储存的数据）。<br /><strong>散列（或哈希）存储：</strong> 根据结点的关键字直接计算出该结点的储存地址。</p><h2 id="常用8种数据结构"><a class="markdownIt-Anchor" href="#常用8种数据结构"></a> 常用8种数据结构</h2><p><strong>数组（Array）</strong> 数组是一种线性结构，而且在物理内存中也占据着一块连续空间。直接通过索引来访问特定的元素，时间复杂度（O(1)）。如果你想在数组的中间插入一个元素，你需要将插入点之后的元素向后移动一位，这需要O(n)的时间复杂度。同样，删除元素也需要将删除点之后的元素向前移动一位，这也需要O(n)的时间复杂度。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//定义并初始化数组</span><br><span class="line">int a[] = &#123;1, 3, 5, 4, 6, 7&#125;;</span><br><span class="line">//访问特定元素并赋值给x</span><br><span class="line">x = a[1];</span><br><span class="line">//删除数字5</span><br><span class="line"><span class="keyword">for</span>(int i = 2; i &lt; 6; i++)&#123;</span><br><span class="line">  a[i] = a[i+1];</span><br><span class="line">&#125;</span><br><span class="line">//假设上面没有操作，还是调用初始数组，在5后面添加一个数字2</span><br><span class="line"><span class="keyword">for</span>(int i = 6; i &gt;= 3; i--)&#123;</span><br><span class="line">  a[i] = a[i-1];</span><br><span class="line">&#125;</span><br><span class="line">a[3] = 2;</span><br><span class="line">//修改5为2</span><br><span class="line">a[2] = 2;</span><br><span class="line">//c++其他数组模板，也可以理解为类</span><br><span class="line">array&lt;int, 5&gt; arr = &#123; 1, 2, 3, 4, 5 &#125;; //有固定大小</span><br><span class="line">vector&lt;int&gt; arr = &#123;1, 2, 3, 4, 5 &#125;;    //可以没有固定大小</span><br><span class="line">valarray&lt;int&gt; arr = &#123; 1, 2, 3, 4, 5 &#125;; //有固定大小</span><br></pre></td></tr></table></figure><p><strong>链表（Linked List）</strong> 链表是物理存储单元上非连续的、非顺序的存储结构，数据元素的逻辑顺序是通过链表的指针地址实现，每个元素包含两个结点，一个是存储元素的数据域 (内存空间)，另一个是指向下一个结点地址的指针域。在链表中，每个元素（称为节点）都包含一个数据部分和一个指向下一个节点的指针。这种结构允许我们在常数时间复杂度（O(1)）下插入和删除节点，因为这仅仅涉及到改变一些指针的指向。然而，随机访问链表中的元素需要从链表的头部开始，沿着指针找到目标元素。由于链表不是连续存储的，我们需要遍历链表，直到找到目标元素。因此，随机访问链表中的元素的时间复杂度是O(n)。这里再继续说一下单链表与双链表，单链表只能通过前一个节点next找到下一个节点，而双链表还可以通过后一个节点prev找到前一个节点。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//单链表</span><br><span class="line">forward_list&lt;int&gt; fl&#123; 1,2,3 &#125;;</span><br><span class="line">//双链表</span><br><span class="line">list&lt;int&gt; l;</span><br><span class="line">// 使用迭代器遍历列表中的元素  </span><br><span class="line"><span class="keyword">for</span> (auto it = l.begin(); it != l.end(); ++it) &#123;  </span><br><span class="line">    std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>队列（Queue）</strong> 队列中的添加和删除数据的操作分别是在两端进行的。队列可以在一端添加元素，在另一端取出元素，也就是：先进先出。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//队列，只能从队首删除元素，队尾插入元素</span><br><span class="line">queue&lt;int&gt;q;  //如果需要访问其他元素，需要不断删除队首元素(pop操作，如果只是遍历保持队列不变，可以在pop前进行push(q.front())操作)</span><br><span class="line">//优先队列，后面的堆将详细介绍</span><br><span class="line">priority_queue&lt;int&gt;pq;</span><br><span class="line">//双端队列，在队首和队尾都可以进行添加删除操作</span><br><span class="line">deque&lt;int&gt;dq;</span><br></pre></td></tr></table></figure><p><strong>栈（Stack）</strong> 栈也是一种数据呈线性排列的数据结构，不过在这种结构中，我们只能访问最新添加的数据。从栈顶放入元素的操作叫入栈，取出元素叫出栈。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//c++模板</span><br><span class="line">stack&lt;int&gt; q;</span><br></pre></td></tr></table></figure><p><strong>树（Tree）</strong> 它是由n（n&gt;=1）个有限节点组成一个具有层次关系的集合。把它叫做 “树” 是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。<br /><strong>散列表（Hash）</strong> 哈希表，也叫散列表，是根据关键码和值 (key和value) 直接进行访问的数据结构，通过key和value来映射到集合中的一个位置，这样就可以很快找到集合中的对应元素。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//unordered_map可以理解为无序映射</span><br><span class="line">unordered_map&lt;string, int&gt; mymap;</span><br><span class="line">mymap[<span class="string">&quot;apple&quot;</span>] = 1; //数组形式插入</span><br><span class="line">pair&lt;string, int&gt; mypair(&#123;<span class="string">&quot;banana&quot;</span>, 2&#125;); //复制插入</span><br><span class="line">mymap.insert(mypair);</span><br><span class="line">mymap.insert(make_pair(<span class="string">&quot;cat&quot;</span>, 3)); //移动插入</span><br><span class="line">mymap.insert(&#123;&#123;<span class="string">&quot;dog&quot;</span>,4&#125;, &#123;<span class="string">&quot;egg&quot;</span>,5&#125;&#125;); //初始化数组插入，可以一次性插入多个</span><br><span class="line">unordered_map&lt;string, int&gt; middle = &#123;&#123;<span class="string">&quot;fat&quot;</span>,6&#125;, &#123;<span class="string">&quot;great&quot;</span>, 7&#125;&#125;; //范围插入</span><br><span class="line">mymap.insert(middle.begin(), middle.end());</span><br><span class="line"><span class="keyword">for</span> (auto&amp; x : mymap)  //输出</span><br><span class="line">      cout&lt;&lt;<span class="string">x.first&lt;&lt;&quot; : &quot;&lt;&lt;x</span>.second&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">//map可以理解为有序映射</span></span><br><span class="line"><span class="string">map&lt;string, int&gt; mymap;</span></span><br></pre></td></tr></table></figure><p><strong>堆（Heap）</strong> 堆是一种图的树形结构，被用于实现“优先队列”(priority queues)。优先队列是一种数据结构，可以自由添加数据，但取出数据时要从最小值开始按顺序取出。在堆的树形结构中，各个顶点被称为“结点”(node)，数据就存储在这些结点中。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//不写后面两个参数默认为vector，less</span><br><span class="line">priority_queue&lt;int&gt; pq1;</span><br><span class="line">//建立一个优先级队列(大堆)，数据类型是int，利用vector容器实现，less（降序）实现</span><br><span class="line">priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; pq2;</span><br><span class="line">//建立一个优先级队列(小堆)，数据类型是int，利用vector容器实现，greater（降序）实现</span><br><span class="line">priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq3;</span><br></pre></td></tr></table></figure><p><strong>图（Graph）</strong> 图是由结点的有穷集合V和边的集合E组成。其中，为了与树形结构加以区别，在图结构中常常将结点称为顶点，边是顶点的有序偶对，若两个顶点之间存在一条边，就表示这两个顶点具有相邻关系。个人认为树可以理解成特殊的有向图，因为树中的边都是父节点与子节点的有向传递（如果该关系定义为1，则所有的边都是一条权重为1的有向边）。</p><h1 id="算法"><a class="markdownIt-Anchor" href="#算法"></a> 算法</h1><p>简单例子看一下普通循环与递归思想</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void PrintN(int N)&#123;</span><br><span class="line">    int i;</span><br><span class="line">    <span class="keyword">for</span>(i=1;i&lt;=N;i++)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;%d&quot;</span> &lt;&lt; <span class="string">i &lt;&lt; endl;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">//递归</span></span><br><span class="line"><span class="string">void PrintN(int N)&#123;</span></span><br><span class="line"><span class="string">    if(N)&#123;</span></span><br><span class="line"><span class="string">        PrintN(n-1);</span></span><br><span class="line"><span class="string">        cout &lt;&lt; &quot;%d&quot; &lt;&lt; N &lt;&lt; endl;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="排序算法"><a class="markdownIt-Anchor" href="#排序算法"></a> 排序算法</h2><p><strong>冒泡排序：</strong> 两个相邻数比较，排序错误就交换位置。由于算法复杂度较高，适合小数据的排序，在数据量大的时候不适合使用。时间：O(n<sup>2</sup>)，空间：O(1)</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void BubbleSort(int a[], int n) &#123;</span><br><span class="line">    int tmp = 0;</span><br><span class="line">    <span class="keyword">for</span> (int i = n - 1; i &gt; 0; i--) &#123; </span><br><span class="line">        //两个相邻数比较后判断是否交换，目的是将位置在[0,i]范围内的最大值放在位置i。eg: 5 3 2 6 4 -&gt; 3 2 5 4 6</span><br><span class="line">        <span class="keyword">for</span> (int j = 0; j &lt; i; j++) &#123;        </span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[j + 1]) &#123;</span><br><span class="line">                tmp = a[j];</span><br><span class="line">                a[j] = a[j + 1];</span><br><span class="line">                a[j + 1] = tmp;</span><br><span class="line">                //swap(a[j], a[j+1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>选择排序：</strong> 从头开始，找到最小值放在开头，然后找第二小的值放在后面，以此类推。适用于简单数据排序。时间：O(n<sup>2</sup>)，空间：O(1)</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void SelectionSort(int a[], int n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (int i = 0; i &lt; n - 1; i++) &#123;</span><br><span class="line">        int min = i;</span><br><span class="line">        //找位置在[i,n-1]范围的最小值</span><br><span class="line">        <span class="keyword">for</span> (int j = i + 1; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[min])</span><br><span class="line">                min = j;</span><br><span class="line">        &#125;</span><br><span class="line">        //交换位置，将第i小的值放在位置i</span><br><span class="line">        swap(a[min], a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>插入排序：</strong> 先将前两个数排序，然后再将第三个数与前两个数比较排序，当前n-1个数排好序后，再将第n个数从n-1的位置开始比较，如果排序错误就交换，以此往前走。适用于数据比较少的时候，一般做为快速排序的扩充。时间：O(n<sup>2</sup>)，空间：O(1)</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void InsertionSort(int a[], int n)&#123;</span><br><span class="line">    //前i个数排好序了，再将第i+1个数插入进去，则前i+1个数就排好序了</span><br><span class="line">    <span class="keyword">for</span>(int i = 1; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt; a[i-1])&#123;</span><br><span class="line">            int j = i - 1;</span><br><span class="line">            int tmp = a[i];    //找到a[i]应该插入的位置，再将其插入进去，同时该右移的数右移一步</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= 0 &amp;&amp; tmp &lt; a[j])&#123;</span><br><span class="line">                a[j+1] = a[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            a[j+1] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>归并排序：</strong> 将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。归并排序在数据量比较大的时候也有较为出色的表现（效率上），但是，其空间复杂度O(n)使得在数据量特别大的时候（例如，1千万数据）几乎不可接受。时间：O(nlogn)，空间：O(n)</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void Merge(int a[], int low, int mid, int high)  //合并函数。还是下面得例子：merge(a, 0, 1, 3)</span><br><span class="line">&#123;</span><br><span class="line">int* b = new int[high - low + 1];  </span><br><span class="line">int i = low, j = mid + 1, k = 0;   </span><br><span class="line">    //第一个<span class="keyword">while</span>是将左边排好序得数组a[i]和右边排好序得数组a[j]进行比较，并将较小的元素放在数组b中，相应的指针向后移动，直到i&gt;mid或者j&gt;high时结束。</span><br><span class="line">    //1.a[0]与a[2]比较，得到b[0]=a[2]=5；2.将a[0]与a[3]比较，得到b[1]=a[0]=15；3.将a[1]与a[3]比较，得到b[2]=a[3]=25 </span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high)&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] &lt;= a[j])</span><br><span class="line">b[k++] = a[i++];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">b[k++] = a[j++];</span><br><span class="line">&#125;</span><br><span class="line">    //由于第一个<span class="keyword">while</span>已经将左右数组其中一个数组得所有元素比较完了（假设左边数组比较完了），所以第三个<span class="keyword">while</span>就是将右边数组直接赋值给b，因为本身是排好序的；否则第二个<span class="keyword">while</span>将左边数组赋值给b。</span><br><span class="line">    //4.由于j=4,i=1，所以最后将a[1]赋值给b[3]</span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid)&#123;</span><br><span class="line">b[k++] = a[i++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (j &lt;= high)&#123;</span><br><span class="line">b[k++] = a[j++];</span><br><span class="line">&#125;</span><br><span class="line">    //5.将排好序的b赋值给a</span><br><span class="line">k = 0;  </span><br><span class="line"><span class="keyword">for</span> (int i = low; i &lt;= high; i++)&#123;</span><br><span class="line">a[i] = b[k++];</span><br><span class="line">&#125;</span><br><span class="line">delete[]b;  </span><br><span class="line">&#125;</span><br><span class="line">//归并排序。注意这里的hign不是前面经常出现的n哦，hign=n-1,就是元素个数减一</span><br><span class="line">void MergeSort(int a[], int low, int high) </span><br><span class="line">//eg:40 15 25 5，low=0，high=3；</span><br><span class="line">//先mergesort(a, 0, 1)计算得：a[0]=15,a[1]=40（中间计算还要经过mergesort(a, 0, 0)，mergesort(a, 1, 1)，merge(a, 0, 0, 1)才得出来的，这里省略了）;</span><br><span class="line">//然后mergesort(a, 2, 3)计算得：a[2]=5,a[3]=25;</span><br><span class="line">//最后merge(a, 0, 1, 3)计算得：a[0]=5,a[1]=15,a[2]=25,a[3]=40。</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (low &lt; high)&#123;</span><br><span class="line">int mid = (low + high) / 2;</span><br><span class="line">MergeSort(a, low, mid);           </span><br><span class="line">MergeSort(a, mid + 1, high);   </span><br><span class="line">Merge(a, low, mid, high);       </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>快速排序：</strong> 1.选取元素的第一个元素作为基准元素；2.从右向左扫描，找到小于等于 pivot 的数，如果找到，将其放置左侧；3.从左向右扫描，找到大于 pivot 的数，如果找到，将其放置右侧；4.重复 步骤二~步骤三，直到 j 与 i 的指针重合，将其作为基准位置返回；5.经过前面步骤，基准左侧值都比基准元素小，右侧都比基准元素大，此时用同样的方法分别将左侧与右侧元素排序。快速排序在大多数情况下都是适用的，尤其在数据量大的时候性能优越性更加明显。时间：O(nlogn)，空间：O(logn)</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void QuickSort(int a[],int low,int high)  //eg:32，25，5，56，17，33</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &gt;= high) <span class="built_in">return</span>;</span><br><span class="line">    int i = low;</span><br><span class="line">    int j = high;</span><br><span class="line">    int key = a[low];</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; key &lt; a[j]) j--;//1.从右向左找比基准元素（32）小的值,找到17,此时j=4</span><br><span class="line">        a[i] = a[j];                    //2.a[0]=a[4]=17       此时 17 25 5 56 17 33</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; key &gt; a[i]) i++;//3.从左向右找比基准元素（32）大的值,找到56，此时i=3</span><br><span class="line">        a[j] = a[i];                   //4.a[4]=a[3]=56        此时17 25 5 56 56 33</span><br><span class="line">    &#125;</span><br><span class="line">    a[i] = key;                       //5.a[3]=32              此时 17 25 32 56 33</span><br><span class="line">    QuickSort(a, low, i-1);  //左边子序列递归排序，用上面的方法对 17 25排序</span><br><span class="line">    QuickSort(a, i+1, high); //右边子序列递归排序，用上面的方法对 56 33排序</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>堆排序：</strong> 堆排序在建立堆和调整堆的过程中会产生比较大的开销，在元素少的时候并不适用。但是，在元素比较多的情况下，还是不错的一个选择。尤其是在解决诸如“前n大的数”一类问题时，几乎是首选算法。时间：O(nlogn)，空间：O(1)。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//最大堆，start是父节点位置，end是最后位置</span><br><span class="line">void Maxheapdown(int a[], int start, int end) //该函数返回父节点、左孩、右孩中最大的值</span><br><span class="line">&#123;</span><br><span class="line">    //建立父节点指标和子节点指标</span><br><span class="line">    int dad = start;</span><br><span class="line">    int son = dad * 2 + 1;  //当前是左孩，比较后更新为孩子中最大值</span><br><span class="line">    <span class="keyword">while</span> (son &lt;= end)&#123; //若子节点指标在范围内才做比较</span><br><span class="line">        <span class="keyword">if</span> (son + 1 &lt;= end &amp;&amp; a[son] &lt; a[son + 1]) //先比较两个子节点大小，选择最大的</span><br><span class="line">            son++;</span><br><span class="line">        <span class="keyword">if</span> (a[dad] &gt; a[son]) //如果父节点大于子节点代表调整完毕，直接跳出函数</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;              //否则交换父子内容再继续子节点和孙节点比较</span><br><span class="line">            swap(a[dad], a[son]);</span><br><span class="line">            dad = son;</span><br><span class="line">            son = dad * 2 + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//堆排序(从小到大)，对数组a进行升序排序，n是数组个数</span><br><span class="line">void HeapSort(int a[], int n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (int i = n / 2 - 1; i &gt;= 0; i--)&#123;   //构造最大堆，数组顺序就是从上到下，从左到右</span><br><span class="line">        Maxheapdown(a, i, n-1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (int i = n - 1; i &gt; 0; i--)&#123;       //最大堆排序方式</span><br><span class="line">        swap(a[0], a[i]);                  //交换元素，将最大元素放在数组最后面，每次交换后都是前面最大值</span><br><span class="line">        Maxheapdown(a, 0, i-1);            //调整最大堆，上一个<span class="keyword">for</span>很多都调整好了，所以这里只调整根节点那里</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**希尔排序：**1.对于n个待排序的数列，取一个小于n的整数gap(gap被称为步长)将待排序元素分成若干个组子序列，所有距离为gap的倍数的记录放在同一个组中。2.对各组内的元素进行直接插入排序（ 这一趟排序完成之后，每一个组的元素都是有序的）。3.减小gap的值，并重复执行上述的分组和排序。4.重复这样的操作，当gap=1时，整个数列就是有序的。希尔排序没有快速排序快 ，在中等大小规模表现良好，希尔算法在最坏的情况下和平均情况下执行效率相差不是很多，与此同时快速排序在最坏的情况下执行的效率会非常差。时间复杂度与步长相关。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void ShellSort(int a[], int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i,j,gap;</span><br><span class="line">    // gap为步长，每次减为原来的一半。</span><br><span class="line">    <span class="keyword">for</span> (gap = n / 2; gap &gt; 0; gap /= 2)&#123;</span><br><span class="line">        <span class="keyword">for</span> (i = 0 ;i &lt; gap; i++)&#123;                //分为gap组</span><br><span class="line">            <span class="keyword">for</span> (j = i + gap; j &lt; n; j += gap)&#123;   //每组排序，就是插入排序的思想，先将前面排好序，后面的插入进来排序</span><br><span class="line">                <span class="keyword">if</span> (a[j] &lt; a[j - gap])&#123;</span><br><span class="line">                    int tmp = a[j];</span><br><span class="line">                    int k = j - gap;</span><br><span class="line">                    <span class="keyword">while</span> (k &gt;= 0 &amp;&amp; a[k] &gt; tmp)&#123;//比如：2 4 8 3，如果没有<span class="keyword">while</span>则结果为2 4 3 8，有<span class="keyword">while</span>结果为2 3 4 8</span><br><span class="line">                        a[k + gap] = a[k];</span><br><span class="line">                        k -= gap;</span><br><span class="line">                    &#125;</span><br><span class="line">                    a[k + gap] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**计数排序：**1.找到数据范围；2.计算数据个数；3.依次排序。计数排序只适用于数据范围较集中的序列的排序，若待排序列的数据较分散，则会造成空间浪费，并且计数排序只适用于整型排序，不适用与浮点型排序。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//eg: 3 5 8 1 2 2 6 5 4 3 1 2 6 8 5 4</span><br><span class="line">void CountSort(int a[], int n)</span><br><span class="line">&#123;</span><br><span class="line">//1.首先找出最大值与最小值,max=8,min=1</span><br><span class="line">int min = a[0];</span><br><span class="line">int max = a[0];</span><br><span class="line"><span class="keyword">for</span> (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] &gt; max)</span><br><span class="line">max = a[i];</span><br><span class="line"><span class="keyword">if</span> (a[i] &lt; min)</span><br><span class="line">min = a[i];</span><br><span class="line">&#125;</span><br><span class="line">//2.开辟内存，range=7+1=8,则count初始化为&#123;0,0,0,0,0,0,0,0&#125;代表0的个数为0，1的个数为0，2的个数为0，3的个数为0，4的个数为0，5的个数为0，6的个数为0，7的个数为0</span><br><span class="line">int range = max - min + 1;</span><br><span class="line">vector&lt;int&gt;  count(range, 0);</span><br><span class="line">//3.统计相同元素出现次数，<span class="keyword">for</span>完过后，count=&#123;2，3，2，2，3，2，0，2&#125;</span><br><span class="line"><span class="keyword">for</span> (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">count[a[i] - min]++;</span><br><span class="line">&#125;</span><br><span class="line">//4.排序</span><br><span class="line">int k = 0;</span><br><span class="line"><span class="keyword">for</span> (int j = 0; j &lt; range; j++) &#123;</span><br><span class="line"><span class="keyword">for</span>(int m = 0; m &lt; count[j]; m++)&#123;</span><br><span class="line">a[k++] = j + min;  //a[0]=1,a[1]=1，然后退出<span class="keyword">while</span>，进入<span class="keyword">for</span>，可以得到a[3]=2,a[4]=2,a[5]=2，再退出<span class="keyword">while</span>，一直下去</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**桶排序：**1.确定元素范围，以及桶的个数；2.将元素放入桶中，在哪个范围放入哪个桶；3.对每个桶排序；4.最后按桶的顺序就排好序了。他的时间复杂度与排序方式有关。这里只看看桶间排序的思想，桶内排序直接使用上诉算法就行了。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void BucketSort(int a[], int n)&#123;</span><br><span class="line">    //1.将元素装入桶中</span><br><span class="line">    vector&lt;int&gt; buckets[10];              //假设定义10个桶，桶的个数竟然与元素个数n一样，实际桶的个数应该是元素最大值/size</span><br><span class="line">    int size = 2;                         //一个桶与另一个桶的间隔</span><br><span class="line">    <span class="keyword">for</span> (int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">        int idx = a[i] / size;            //可以计算出a[i]元素属于哪个桶的索引。注意：因为这里直接除以size，所以元素都是&gt;=0的，[0,size-1]属于桶0，[size,2size-1]属于桶1，……</span><br><span class="line">        buckets[idx].push_back(a[i]);     //入桶</span><br><span class="line">    &#125;</span><br><span class="line">    //2.桶内无序，桶间有序，如果需要排好序，可以调用上面的排序算法进行桶间排序</span><br><span class="line">    int l = 0;</span><br><span class="line">    <span class="keyword">for</span> (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (int j = 0; j &lt; buckets[i].size(); j++) &#123;</span><br><span class="line">            a[l++] = buckets[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**基数排序：**首先将所有待比较数字统一为统一位数长度，接着从最低位开始，依次进行排序。排序后，数列就变成了一个有序序列。这里用了桶排序的思想，因为每次排序都只需要10个桶。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void RadixSort(int a[], int n, int max)</span><br><span class="line">&#123;</span><br><span class="line">    //1.计算最大数的位数</span><br><span class="line">    int d = 1;</span><br><span class="line">    <span class="keyword">while</span> (max) &#123;</span><br><span class="line">        ++d;</span><br><span class="line">        max /= 10;</span><br><span class="line">    &#125;</span><br><span class="line">    //2.d位数就进行d次排序，每次都用桶排序，只需要桶间有序就可以了，桶内无序没关系</span><br><span class="line">    vector&lt;int&gt; buckets[10];   //数字是0-9，所以需要10个桶</span><br><span class="line">    int radix = 1;             //radix=1是个位数排序，radix=10是十位数排序，以此类推</span><br><span class="line">    int m;                     //桶的索引</span><br><span class="line">    <span class="keyword">for</span> (int i = 1; i &lt;= d; i++)</span><br><span class="line">    &#123; </span><br><span class="line">        int z = 0;                 //数组排序索引</span><br><span class="line">        //入桶</span><br><span class="line">        <span class="keyword">for</span> (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">            m = (a[j] / radix) % 10;</span><br><span class="line">            buckets[m].push_back(a[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        //桶间排序就够了</span><br><span class="line">        <span class="keyword">for</span> (int k = 0; k &lt; 10; k++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (int l = 0; l &lt; buckets[k].size(); l++) &#123;</span><br><span class="line">                a[z++] = buckets[k][l];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        radix = radix * 10;</span><br><span class="line">        //每次排序完清空桶</span><br><span class="line">        <span class="keyword">for</span> (int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">            buckets[i].clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找算法"><a class="markdownIt-Anchor" href="#查找算法"></a> 查找算法</h2><p><strong>顺序查找：</strong> 对于任意一个序列，从一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，若相等则表示查找成功；若扫描结束仍没有找到关键字等于k的结点，表示查找失败。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int SequentialSearch(int a[], int n, int key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (int i = 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == key)</span><br><span class="line">            <span class="built_in">return</span> i;      //返回位置i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> -1;             //没找到</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二分查找：</strong> 1.确定查找范围low=0，high=N-1，计算中项mid=（low+high）/2。2.若mid==x或low&gt;=high,则结束查找；否则，向下继续。3.若<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>m</mi><mi>i</mi><mi>d</mi><mo>&lt;</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">amid&lt;x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span><span class="mrel">&lt;</span><span class="mord mathit">x</span></span></span></span>,说明待查找的元素值只可能在比中项元素大的范围内，则把mid+1的值赋给low，并重新计算mid，转去执行步骤2；若<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi><mo>&gt;</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">mid&gt;x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span><span class="mrel">&gt;</span><span class="mord mathit">x</span></span></span></span>，说明待查找的元素值只可能在比中项元素小的范围内，则把mid-1的值赋给high，并重新计算mid，转去执行步骤2。(注：必须先排好序)</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int BinarySearch(int a[], int n, int key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == NULL || n == 0)</span><br><span class="line">        <span class="built_in">return</span> -1;</span><br><span class="line">    int low = 0;</span><br><span class="line">    int high = n - 1;</span><br><span class="line">    int mid = 0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (low + high) / 2;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &lt; key)</span><br><span class="line">            low = mid + 1;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &gt; key)</span><br><span class="line">            high = mid - 1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>插值查找：</strong> 类似于二分查找思想，只是计算mid方式不同。mid=low+(key-a[low])/(a[high]-a[low])*(high-low)  （注：仍然有序）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int InterpolationSearch(int a[], int n, int key) &#123;</span><br><span class="line">int left = 0;</span><br><span class="line">int right = n - 1;</span><br><span class="line">int mid;</span><br><span class="line">// 终止条件</span><br><span class="line"><span class="keyword">while</span> (left &lt; right)</span><br><span class="line">&#123;</span><br><span class="line">// 中间位置计算</span><br><span class="line">mid = left + int((key - a[left]) / (a[right] - a[left]) * (right - left));</span><br><span class="line"><span class="keyword">if</span> (a[mid] == key) &#123;</span><br><span class="line"><span class="built_in">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line">// 目标值在中间值右边，更新左位置</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; key) &#123;</span><br><span class="line">left = mid + 1;</span><br><span class="line">&#125;</span><br><span class="line">// 目标值在中间值左边，更新右位置</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">right = mid - 1;</span><br><span class="line">&#125;</span><br><span class="line">// 只剩最后一个元素时</span><br><span class="line"><span class="keyword">if</span> (left == right) &#123;</span><br><span class="line"><span class="keyword">if</span> (key == a[left]) &#123;</span><br><span class="line"><span class="built_in">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>斐波那契查找：</strong> 也是二分查找的一种提升算法，通过运用黄金比例的概念在数列中选择查找点进行查找，斐波那契数列：{1, 1, 2, 3, 5, 8, 13, 21, 34, 55，……}。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//斐波那契数列，a[n]=a[n-1]+a[n-2]，这里就是求第n个数的值a[n]=f</span><br><span class="line">int Fibonacci(int n)</span><br><span class="line">&#123;</span><br><span class="line">int f = 0, g = 1;</span><br><span class="line"><span class="keyword">while</span> (n--)</span><br><span class="line">&#123;</span><br><span class="line">g += f;</span><br><span class="line">f = g - f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line">//eg:1,5,7,12,15,25,84,86,92,99   查找12</span><br><span class="line">int FibonacciSearch(int* a, int n, int key)</span><br><span class="line">&#123;</span><br><span class="line">int low = 1, high = n, mid, i, k = 0;</span><br><span class="line"><span class="keyword">while</span> (n &gt; Fibonacci(k) - 1)k++;                   //1. n=10，则k=7</span><br><span class="line"><span class="keyword">for</span> (i = n; i &lt; Fibonacci(k) - 1; i++)a[i] = a[n]; //2. a[10]=a[11]=a[9]=99</span><br><span class="line"><span class="keyword">while</span> (low &lt;= high)</span><br><span class="line">&#123;</span><br><span class="line">mid = low + Fibonacci(k - 1) - 1;         //3.k=6,mid=8,a[8]=92 5.k=4,mid=3,a[3]=12</span><br><span class="line"><span class="keyword">if</span> (key &lt; a[mid])</span><br><span class="line">&#123;</span><br><span class="line">high = mid - 1;                  //4.high=7,k=5</span><br><span class="line">k -= 1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key &gt; a[mid])</span><br><span class="line">&#123;</span><br><span class="line">low = mid + 1;</span><br><span class="line">k -= 2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (mid &lt;= n)<span class="built_in">return</span> mid;        //6.返回mid=3</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分块查找：</strong> 将n个数据元素”按块有序”划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须”按块有序”；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，……。1、先选取各块中的最大关键字构成一个索引表；2、查找分两个部分：先对索引表进行二分查找或顺序查找，以确定待查记录在哪一块中；3、在已确定的块中用顺序法进行查找。（如果块内也有序的话，则所有元素都是排好序的，此时也就分成几等份，看查找元素在哪个区间而已）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">    int bockts_max;            //bockts_max为块内最大值 </span><br><span class="line">    int <span class="built_in">link</span>;                 //指向对应块的起始下标 </span><br><span class="line">&#125; IdxType;</span><br><span class="line">typedef IdxType IDX[100];   //索引表类型 </span><br><span class="line"></span><br><span class="line">int ChunkSearch(IDX I, int m, int a[], int n, int key)&#123;   </span><br><span class="line">    int low = 0, high = m - 1, mid, i;</span><br><span class="line">    int b = n / m;                        //b为每块的记录个数</span><br><span class="line">    //二分查找找属于的块</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high)     </span><br><span class="line">    &#123;</span><br><span class="line">        mid = (low + high) / 2;</span><br><span class="line">        <span class="keyword">if</span> (I[mid].bockts_max &gt;= key)</span><br><span class="line">            high = mid - 1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            low = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    //找到块后，从块的最小索引开始查找元素位置</span><br><span class="line">    i = I[high + 1].<span class="built_in">link</span>;           //I[high + 1].<span class="built_in">link</span>为块中的最小索引</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= I[high + 1].<span class="built_in">link</span> + b - 1 &amp;&amp; a[i] != key) //没找到，索引就加一。要么找到；要么直到索引进入下一个块，则认为没找到</span><br><span class="line">        i++;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= I[high + 1].<span class="built_in">link</span> + b - 1)</span><br><span class="line">        <span class="built_in">return</span> i;            //返回查找成功后该数值在数组中的索引</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br><span class="line">//下面就是举的例子</span><br><span class="line">int <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    IDX I = &#123; &#123; 14,0 &#125;,&#123; 34,5 &#125;,&#123; 66,10 &#125;,&#123; 85,15 &#125;,&#123; 100,20 &#125; &#125;;</span><br><span class="line">    int a[] = &#123; 8,14,6,9,10, 22,34,18,19,31, 40,38,54,66,46, 71,78,68,80,85, 100,94,88,96,87 &#125;;</span><br><span class="line">    int target = 5; </span><br><span class="line">    int index = ChunkSearch(I, 5, a, 25, 22);</span><br><span class="line">    <span class="keyword">if</span> (index != -1) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Target found at index &quot;</span> &lt;&lt; <span class="string">index &lt;&lt; endl;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    else &#123;</span></span><br><span class="line"><span class="string">        cout &lt;&lt; &quot;Target not found&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>树表查找：</strong><br /><strong>散列表查找：</strong></p><h2 id="贪心算法"><a class="markdownIt-Anchor" href="#贪心算法"></a> 贪心算法</h2><p><strong>原理：</strong> 贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解。简单说，就是一个大问题分解成几个小问题，几个小问题的最优解的和就是大问题的最优解。举两个例子。<br />**1.**dijkstar算法，但是该算法求解的最短距离不一定全局最优，因为走的下一个点并不是全局最优经过的点，或者说全局最优的点无法到达局部最优那个点（因为画成了小格子，所以一个点只能到达顶点，但是实际最短路线可能会经过边），举个例：在不考虑障碍物情形下，原点和终点在一个简单的3*4小格子的对角线上，用贪心算法算出来的最短距离为1+3sqrt(2)（这里用的欧氏距离，但是贪心算法必须到达一个顶点） ，实际全局最短距离为5，虽然不是全局最优，但是也算接近。但是如果原点和终点在同一边上，则贪心算法就是全局最优。<br />**2.**钱币找零问题，假如有15元，需要用11、5、1三种面额的钱币来表示，如果用贪心算法来选择的话，会从11开始选择，这样就会选出一张11面额和4张1元面额的方案，但实际上，用3张5元面额的方案，使用的钱币更少，此时贪心方案就选不出全局最优解。</p><h2 id="暴力递归"><a class="markdownIt-Anchor" href="#暴力递归"></a> 暴力递归</h2><p><strong>青蛙问题：</strong> 一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 10 级的台阶总共有多少种跳法。<br /><strong>思路：</strong> 要想跳到第10级台阶，要么是先跳到第9级，然后再跳1级台阶上去;要么是先跳到第8级，然后一次迈2级台阶上去，则f(10)=f(9)+(8)。以此类推。</p><h2 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h2><p><strong>原理：</strong> 若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量： 一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。 这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。类似暴力递归，但是这里用空间去换时间。<br /><strong>青蛙问题思路：</strong> f(1)=1,f(2)=2,f(3)=f(1)+f(2)=3,……,f(n)=f(n-1)+f(n-2)。先储存f(1),f(2),算一个存一个，直到算出f(n)。<br /><strong>背包问题：</strong> 假设我们有n种类型的物品，分别编号为1, 2…n。其中编号为i的物品价值为vi，它的重量为wi。为了简化问题，假定价值和重量都是整数值。现在，假设我们有一个背包，它能够承载的重量是Cap。现在，我们希望往包里装这些物品，使得包里装的物品价值最大化，那么我们该如何来选择装的东西呢？注意：每种物品只有一件，可以选择放或者不放。初始化数据为：n=5，w={2,2,6,5,4}，v={6,3,5,4,6}，Cap=10<br /><strong>背包思路：</strong> f[i][j]=max(f[i-1][j],f[i-1][j-w[i]]+p[i])，i代表子问题，j代表承重，f(i)(j)代表第i个问题下满足承重j下的最优价值，w[i]为第i号物品的重量，p[i]为第i号物品的价值。比如：f[2][10],就是从2的个问题（1.2号物品中）找出承重量为3的最优价值，f[2][3]=max(f[1][3],f[1][1]+3)，这里要么选择前一个问题值，要么在满足承重条件下加上2号物品价值，两个选最大的就行了。<br /><strong>分解的5个子问题：</strong> 1.从1号物品中分别找出背包承重[0，10]的最优解。2.从1.2号物品中分别找出背包承重[0，10]的最优解，很明显从4开始,最优解v=9。3.从1.2.3号物品中分别找出背包承重[0，10]的最优解。4.从1.2.3.4号物品中分别找出背包承重[0，10]的最优解。5.从1.2.3.4.5号物品中分别找出背包承重[0，10]的最优解。<br /><strong>下表为每个子问题对应承重的最优解</strong></p><table><thead><tr><th style="text-align:center">子问题\承重</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">6</td><td style="text-align:center">6</td><td style="text-align:center">6</td><td style="text-align:center">6</td><td style="text-align:center">6</td><td style="text-align:center">6</td><td style="text-align:center">6</td><td style="text-align:center">6</td><td style="text-align:center">6</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">6</td><td style="text-align:center">6</td><td style="text-align:center">9</td><td style="text-align:center">9</td><td style="text-align:center">9</td><td style="text-align:center">9</td><td style="text-align:center">9</td><td style="text-align:center">9</td><td style="text-align:center">9</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">6</td><td style="text-align:center">6</td><td style="text-align:center">9</td><td style="text-align:center">9</td><td style="text-align:center">9</td><td style="text-align:center">9</td><td style="text-align:center">11</td><td style="text-align:center">11</td><td style="text-align:center">14</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">6</td><td style="text-align:center">6</td><td style="text-align:center">9</td><td style="text-align:center">9</td><td style="text-align:center">9</td><td style="text-align:center">10</td><td style="text-align:center">11</td><td style="text-align:center">13</td><td style="text-align:center">14</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">6</td><td style="text-align:center">6</td><td style="text-align:center">9</td><td style="text-align:center">9</td><td style="text-align:center">12</td><td style="text-align:center">12</td><td style="text-align:center">15</td><td style="text-align:center">15</td><td style="text-align:center">15</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dwa算法的理解</title>
      <link href="/2023/10/31/dwa%E7%AE%97%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2023/10/31/dwa%E7%AE%97%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="dwa算法流程源码是dwb"><a class="markdownIt-Anchor" href="#dwa算法流程源码是dwb"></a> dwa算法流程(源码是dwb)：</h1><h2 id="step1计算速度样本"><a class="markdownIt-Anchor" href="#step1计算速度样本"></a> step1:计算速度样本</h2><p>在计算速度样本过程中，先通过速度约束（速度限制，加速度约束，障碍物约束）等生成一个速度范围，也就是所有限制做个交集；然后将速度分成几份。eg：线速度为[0,1],角速度为[0,1]，都将速度分为11份；那么组合成的速度样本有 [0,0],[0,0.1],[0,0.2],……,[1,0.9],[1,1] 。在nav2源码中vx_samples、vy_samples、vtheta_samples、linear_granularity、angular_granularity这几个参数都是为了划分速度样本。</p><h2 id="step2对每个样本速度生成轨迹"><a class="markdownIt-Anchor" href="#step2对每个样本速度生成轨迹"></a> step2:对每个样本速度生成轨迹</h2><p>通过s=vt可以计算路径，如果是二维且速度都不为0的情形下会是一条弧线，这个自己去看运动学，很好理解，比如：线速度为0m/s，角速度为1m/s，机器人原地旋转。</p><h2 id="step3对每一条生成轨迹进行评分选择最优路径"><a class="markdownIt-Anchor" href="#step3对每一条生成轨迹进行评分选择最优路径"></a> step3:对每一条生成轨迹进行评分，选择最优路径</h2><p>评分主要是对目标点、路径、障碍物进行评分，当然可以加入其他评分标准。目标点主要是为了让机器人向前移动；路径是为了让机器人移动轨迹与规划路线更贴合，也就是让机器人跟着规划路线走；障碍物就是为了避障。nav2相关参数BaseObstacle.scale、PathAlign.scale、PathAlign.forward_point_distance、GoalAlign.scale、GoalAlign.scale、forward_point_distance、PathDist.scale、GoalDist.scale、RotateToGoal.scale、RotateToGoal.slowing_factor、RotateToGoal.lookahead_time。</p><h2 id="step4发布局部规划和代价图并返回best对应的速度"><a class="markdownIt-Anchor" href="#step4发布局部规划和代价图并返回best对应的速度"></a> step4:发布局部规划和代价图，并返回best对应的速度</h2><p>这里是评分越低的越好，权重越高影响越大。然后分数最低的轨迹对应的速度发布出来</p><h2 id="step5将step4中的速度发布到控制"><a class="markdownIt-Anchor" href="#step5将step4中的速度发布到控制"></a> step5：将step4中的速度发布到控制</h2><p>在nav2中dwa算法生成的轨迹发布到nav2_controller文件，也可以将dwa替换成teb等局部规划算法。</p><h2 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h2><p>1.当设置目标点容差过低时，机器人会有抖动现象，那是因为机器人越靠近目标点，机器人就会一直减速，这跟硬件有关，好点的硬件是看不出来啥的，如果硬件没办法，自己也可以增加评分器进行优化<br />2.sim_time是仿真时间，你可以当作用来模拟轨迹评分</p>]]></content>
      
      
      <categories>
          
          <category> 机器人路径规划算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 局部路径规划算法 </tag>
            
            <tag> ROS </tag>
            
            <tag> 机器人 </tag>
            
            <tag> DAW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Liunx的一些问题与方法</title>
      <link href="/2023/10/19/Liunx%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
      <url>/2023/10/19/Liunx%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E4%B8%8E%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-error-eacces-permission-denied保存修改wsl中文件出错因为没有权限"><a class="markdownIt-Anchor" href="#1-error-eacces-permission-denied保存修改wsl中文件出错因为没有权限"></a> 1. Error: EACCES: permission denied保存修改wsl中文件出错，因为没有权限</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo <span class="built_in">chmod</span> -R 777 /文件目录</span><br></pre></td></tr></table></figure><h2 id="2-删除liunx文件夹"><a class="markdownIt-Anchor" href="#2-删除liunx文件夹"></a> 2. 删除liunx文件夹</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">rm</span> -rf /文件夹目录（慎用-rf，因为不能恢复）</span><br><span class="line">$ <span class="built_in">rm</span> ./* （如果进入该文件夹，该命令为删除文件夹下所有文件，不包括文件夹）</span><br></pre></td></tr></table></figure><h2 id="3-删除linux系统"><a class="markdownIt-Anchor" href="#3-删除linux系统"></a> 3. 删除linux系统</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wsl --list（查看wsl列表）</span><br><span class="line">$ wsl --unregister Ubuntu-20.04（删除Ubuntu-20.04）</span><br></pre></td></tr></table></figure><h2 id="4-linux解压压缩文件"><a class="markdownIt-Anchor" href="#4-linux解压压缩文件"></a> 4. linux解压压缩文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">unzip ./wenjian.zip</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> liunx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> liunx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL笔记</title>
      <link href="/2023/10/19/MYSQL%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/10/19/MYSQL%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>1.打开mysql<br />cmd-&gt;mysql -u root -p</p><h2 id="一-数据库表的操作ddl"><a class="markdownIt-Anchor" href="#一-数据库表的操作ddl"></a> 一、数据库/表的操作（DDL）:</h2><p>2.查询所有数据库：<br />show databases;<br />3.创建：<br />create database (if not exists可加看自己需求) XXX(数据库名) (default charset utf8mb4字符集，看需求);<br />4.删除<br />drop database XXX;<br />5.使用/切换数据库<br />use XXX;<br />6.查看当前使用哪个数据库<br />select database();<br />——将mydata2数据库的编码修改为utf-8；<br />alter database mydata2 character set utf8;<br />——查看数据的定义信息：<br />show create database mydata;<br />7.显示数据库中的表<br />show tables;<br />8.查看表的字段信息：<br />desc student;<br />9.在上面员工表的基本上增加一个address列：（表中加列）<br />alter table student add address varchar(1000);<br />10.修改name列，使其长度为30：<br />alter table student modify name varchar(30);<br />11.删除address列,一次只能删一列：<br />alter table student drop address;<br />12.表名改为user：<br />rename table student to user;<br />13.查看表格的创建细节：<br />show create table user;<br />14.修改表的字符集为gbk：<br />alter table user character set gbk;<br />15.列名name修改为username：<br />alter table user change name username varchar(20)；<br />16.删除表：<br />drop table user;<br />17.数据类型：数值型、字符型、时间<br />18.创建表<br />create table student(<br />id int comment ‘编号’,<br />name varchar(50) comment ‘姓名’) comment ‘学生信息表’;</p><p>DDL总结：<br />show databases;<br />create/drop database 数据库名;<br />use 数据库名;<br />select database();<br />show tables;<br />create/drop table 表名（字段 字段类型 ,字段 字段类型）;<br />desc 表名;<br />show create table 表名;<br />alter table 表名 add/modify/change/drop/rename to …;</p><h2 id="二-dml对数据库中表的数据记录进行增删改查"><a class="markdownIt-Anchor" href="#二-dml对数据库中表的数据记录进行增删改查"></a> 二、DML:对数据库中表的数据记录进行增删改查</h2><p>增：insert into 表名(字段1， 字段2) values(值1， 值2);<br />改：update 表名 set 字段1 = ‘修改值’, 字段2 = ‘修改值’  where … （where后面为查询条件）;<br />删：delete from 表名 where …;</p><h2 id="三-dql查询数据库中表的记录"><a class="markdownIt-Anchor" href="#三-dql查询数据库中表的记录"></a> 三、DQL:查询数据库中表的记录</h2><p>基本查询：select … from …<br />条件查询：where<br />聚合函数：count、max、min、avg、sum<br />分组查询：group by         having是聚合函数里的条件，在group by后面进行筛选<br />排序查询：order by<br />分页查询：limit</p><p>编写顺序：select … from … where … group by … having … order by … limit …<br />执行顺序：from … where … group by … having … order by … limit …</p><h2 id="四-dcl管理数据库用户控制数据库访问权限"><a class="markdownIt-Anchor" href="#四-dcl管理数据库用户控制数据库访问权限"></a> 四、DCL：管理数据库用户，控制数据库访问权限</h2><p>管理用户：'%'任意主机，'localhost’当前主机<br />1.查询用户<br />use mysql;<br />select * from user;<br />2.创建用户<br />create user ‘用户名’@‘主机名’ identified by ‘密码’;<br />3.修改用户名密码<br />alter user ‘用户名’@‘主机名’ identified with mysql_native_password by ‘密码’;<br />4.删除用户<br />drop  user ‘用户名’@‘主机名’;<br />权限：all代表所有权限<br />查询权限：show grants for ‘用户名’@‘主机名’;<br />授予权限：grant 权限列表 on 数据库.表名 to ‘用户名’@‘主机名’;  eg:grant all on 数据库.* to ‘用户名’@‘主机名’;-&gt;显示：grant all privieges on 数据库.* to ‘用户名’@'主机名’表示数据库所有表的权限授予用户<br />撤销权限：revoke 权限列表 on 数据库.表名 from ‘用户名’@‘主机名’;</p><p>函数：<br />1.字符串：concat、lower、upper、lpad、rpad、trim、substring<br />2.数值：ceil、floor、mod、rand、round<br />3.日期：curdate、curtime、now、year、month、day、date_add、datediff<br />4.流程：if、ifnull、case[…] when…then…else…end<br />约束：<br />not null、unique、primary key、default、check、foreign key<br />eg:alter table 表名 add constraint 外键名 foreign key （外键字段名） references 主表(主表列名);</p><p>多表查询：<br />显式内联：select 字段列表 from 表1 inner join 表2 on 连接条件;<br />隐式：elect 字段列表 from 表1,表2 where 条件;<br />左外联：select 字段列表 from 表1 left join 表2 on 连接条件;<br />右：select 字段列表 from 表1 right join 表2 on 连接条件;<br />自：select 字段列表 from 表1join 表2 on 连接条件;<br />联合：union all、union(去掉查询后的重复值)<br />eg:查询所有工资小于5000和年龄大于50的员工都查出来select * from 表 where s &lt; 5000 union all select * from 表 where age &gt; 50;<br />子查询：select * from t where column = (select column from t1);<br />select * from t where (字段1，字段2) =/in (select 字段1，字段2 from t1 where …);</p><p>事务：一组操作集合，把所有操作作为一个整体向系统提交/撤销请求<br />eg:a转1000给b<br />select * from account where name = “a”;<br />update account set money = money - 1000 where name = ‘a’;<br />update account set money = money + 1000 where name = ‘b’;</p><p>开启：start transaction、begin<br />提交：commit;<br />回滚：rollvack;</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ros2机器人常见问题以及一些使用方法</title>
      <link href="/2023/10/19/ros%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/2023/10/19/ros%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h1><h2 id="1-ros2build出错setuptoolsdeprecationwarning-setuppy-install-is-deprecated-use-build-and-pip-and-other"><a class="markdownIt-Anchor" href="#1-ros2build出错setuptoolsdeprecationwarning-setuppy-install-is-deprecated-use-build-and-pip-and-other"></a> 1. ros2build出错：SetuptoolsDeprecationWarning: <a href="http://setup.py">setup.py</a> install is deprecated. Use build and pip and other…</h2><p>办法：该问题为版本问题，将python版本降低为58.2.0即可</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo pip install -i https://pypi.tuna.tsinghua.edu.cn/simple setuptools==58.2.0 --upgrade</span><br></pre></td></tr></table></figure><p>备注：可以通过以下命令查看python3版本：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3</span><br><span class="line">$ import setuptools</span><br><span class="line">$ <span class="built_in">print</span>(setuptools.__version__)</span><br></pre></td></tr></table></figure><h2 id="2-cmake-error-the-source-directory-文件位置-does-not-exist"><a class="markdownIt-Anchor" href="#2-cmake-error-the-source-directory-文件位置-does-not-exist"></a> 2. CMake Error: The source directory “文件位置” does not exist.</h2><p>因为前面编译了该文件，后来将其删除后，没有将build中的记录删除，删除即可</p><h2 id="3-no-such-file-or-directory"><a class="markdownIt-Anchor" href="#3-no-such-file-or-directory"></a> 3. No such file or directory</h2><p>缺少该文件，否则查看文件名字可能与库不一致，仔细检查</p><h2 id="4-rosdepc-update失败"><a class="markdownIt-Anchor" href="#4-rosdepc-update失败"></a> 4. rosdepc update失败</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo rosdepc init</span><br><span class="line">$ rosdepc update</span><br></pre></td></tr></table></figure><h1 id="使用方法"><a class="markdownIt-Anchor" href="#使用方法"></a> 使用方法</h1><h2 id="1-依赖问题可以使用rosdepc进行依赖的安装然后对依赖中的版本进行无视鱼香ros真的很好用"><a class="markdownIt-Anchor" href="#1-依赖问题可以使用rosdepc进行依赖的安装然后对依赖中的版本进行无视鱼香ros真的很好用"></a> 1. 依赖问题：可以使用rosdepc进行依赖的安装，然后对依赖中的版本进行无视（鱼香ros真的很好用）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget http://fishros.com/install -O fishros &amp;&amp; . fishros</span><br><span class="line">$ rosdepc install -r --from-paths src --ignore-src --rosdistro <span class="variable">$ROS_DISTRO</span> -y</span><br></pre></td></tr></table></figure><h2 id="2-切换teb算法"><a class="markdownIt-Anchor" href="#2-切换teb算法"></a> 2. 切换teb算法</h2><p>首先下载源码：可以下载压缩文件，也可以git。teb有的需要costmap_converter文件，所以都下载<br />然后安装依赖：<code>rosdep install -i --from-path src --rosdistro galactic -y</code>（用什么版本就换什么，比如这里用galactic）<br />最后修改yaml文件替换dwb插件，编译，测试</p><h2 id="3-ros2自定义msg"><a class="markdownIt-Anchor" href="#3-ros2自定义msg"></a> 3. ros2自定义msg</h2><p>(1)创建msg文件,修改cmake，修改package<br />(2)订阅话题，可以直接将话题数据拿去用，也可以赋值给私有变量x，x再拿去做运算</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public:</span><br><span class="line">  example_subscribe_ = create_subscription&lt;xxx::msg::Example&gt;(<span class="string">&quot;example&quot;</span>, 10, std::<span class="built_in">bind</span>(&amp;类名::examplesubscribecallback, this, std::placeholders::_1));</span><br><span class="line">private:</span><br><span class="line">  double x;</span><br><span class="line">  rclcpp::Subscription&lt;nav2_msgs::msg::Person&gt;::SharedPtr example_subscribe_;</span><br><span class="line">  void examplebscribecallback(const xxx::msg::Example::SharedPtr msg)</span><br><span class="line">  &#123;</span><br><span class="line">    x=msg-&gt;x;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>注意：头文件：#include “xxx/msg/example.hpp”，必须小写，如果是ExampleExample这种命名的，头文件#include &quot;xxx/msg/example_example.hpp&quot;这么写</p><h2 id="4-ros2手动发布目标点"><a class="markdownIt-Anchor" href="#4-ros2手动发布目标点"></a> 4. ros2手动发布目标点</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ros2 action send_goal /navigate_to_pose nav2_msgs/action/NavigateToPose <span class="string">&quot;&#123;pose: &#123;header: &#123;frame_id: &#x27;map&#x27;&#125;,pose: &#123;position: &#123;x: 0.0,y: 0.0&#125;,orientation: &#123;w: 1.0&#125;&#125;&#125;&#125;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="5-rqt中话题使用"><a class="markdownIt-Anchor" href="#5-rqt中话题使用"></a> 5. rqt中话题使用</h2><p>rqt-&gt;plugins-&gt;topic-&gt;message publisher-&gt;选择所需话题和消息类型-&gt;右上角点击+号-&gt;勾选</p><h2 id="6-搭建ros仿真环境"><a class="markdownIt-Anchor" href="#6-搭建ros仿真环境"></a> 6. 搭建ros仿真环境</h2><p>（1）gazebo-&gt;Edit-&gt;Building Editor-&gt;绘制好墙-&gt;保存-&gt;退出-&gt;添加物品-&gt;保存至world文件夹<br />（2）修改gazebo的launch文件中的新建图world名字-&gt;启动gazebo的launch-&gt;启动cartographer的launch，-&gt;启动遥控<code>ros2 run teleop_twist_keyboard teleop_twist_keyboard</code> -&gt;走完先暂停再地图后保存地图<br />（3）保存地图前安装<code>sudo apt install ros-humble-nav2-map-server</code>-&gt;再保存地图:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> src/cartographer目录/ &amp;&amp; <span class="built_in">mkdir</span> map &amp;&amp; <span class="built_in">cd</span> map（如果有这个目录直接进入该目录，然后运行下面的程序）</span><br><span class="line">$ ros2 run nav2_map_server map_saver_cli -t map -f 文件名</span><br></pre></td></tr></table></figure><h2 id="7-写一个定时器通过计算时间戳去计算时间间隔"><a class="markdownIt-Anchor" href="#7-写一个定时器通过计算时间戳去计算时间间隔"></a> 7. 写一个定时器，通过计算时间戳去计算时间间隔</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rclcpp::Clock steady_clock_&#123;RCL_STEADY_TIME&#125;;</span><br><span class="line">start_time_= steady_clock_.now();   //当前时间戳</span><br><span class="line">time = steady_clock_.now().seconds() - start_time_.seconds();    //当前时间与start_time_之间的时间间隔</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ROS与机器人相关问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全局路径规划算法源码理解</title>
      <link href="/2023/10/19/%E5%85%A8%E5%B1%80%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/"/>
      <url>/2023/10/19/%E5%85%A8%E5%B1%80%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="1设置代价图更新代价值"><a class="markdownIt-Anchor" href="#1设置代价图更新代价值"></a> 1.设置代价图，更新代价值</h2><p>cmap=[0,253)-&gt;[50,252.4)，cmap=254-&gt;254,cmap=255-&gt;253，将代价值[0，255]更新为[50,254]</p><h2 id="2设置potential数组"><a class="markdownIt-Anchor" href="#2设置potential数组"></a> 2.设置potential数组</h2><p>将所有potarr设置为最大值。首先封闭地图边缘，将其代价值都设为254（障碍）；然后初始化传播数组；最后将终点的potarr值（行走代价值）置为0，并且将上下左右四个栅格节点放入curP</p><h2 id="3通过dijkstra算法以广度优先的方式更新potential数组"><a class="markdownIt-Anchor" href="#3通过dijkstra算法以广度优先的方式更新potential数组"></a> 3.通过dijkstra算法以广度优先的方式更新potential数组</h2><p>利用 v = -0.2301dd + 0.5307d + 0.7040 , pot = ta + hfv公式计算获得的potential分布是以圆的形式向外传播，而直接利用pot = ta+hf这个公式计算获得的potential分布是以方形的形式向外传播，明显以圆的形式向外传播的这种分布方式更结合实际。当设置传播界限时，传播方式是以potential值为边界一步步向外传播，而不设置传播界限时，就是以固定的方形传播方式往外传播，会增加很多额外的不必要传播．所以设置边界能提高传播速度．（可以参考广度优先搜索算法，本身是无向图）</p><p>更新potarr：先通过邻居potarr去计算pot，然后对比初始的potarr来对其更新，然后如果邻居不是障碍物就将邻居加入nextpe，当把curpe中的potarr更新完后，再将nextpe全部当作curpe，再去更新potarr，再得到新的nextpe，以此类推循环。这样就会得到目标点到地图所有点的potarr值。当起点的potarr值小于最大默认值时，即说明已经传播到了目标点，此时就可以结束传播过程</p><h2 id="4计算轨迹"><a class="markdownIt-Anchor" href="#4计算轨迹"></a> 4.计算轨迹</h2><p>从目标点开始沿着最优行走代价值梯度下降的方向寻找到起点的最优轨迹。前面计算的potarr都是&gt;50的，因为代价值经过转换是在[50,]范围内</p><h2 id="dijkstra"><a class="markdownIt-Anchor" href="#dijkstra"></a> dijkstra</h2><p>简单说就是，先设置终点的potarr值为0，其余的点设置为10<sup>10。然后通过算法一步步计算终点到各个点的最小potarr值（因为知道起点的索引，所以当起点的potarr值&lt;10</sup>10时，即找到终点到起点的最小potarr值，则结束）。最后再规划起点到终点的路径（从起点出发，寻找邻居最小的potarr值，然后将其加入全局路径点，直到找到potarr值小于50（只有终点为0&lt;50），至此生成所有路径点。</p><h2 id="astar"><a class="markdownIt-Anchor" href="#astar"></a> astar</h2><p>看算法与dijkstra差不多，主要区别在于加入nextpe前，pot的计算变为pot+dist(pot是计算该点到终点的potarr最小值，dist是计算该点到起点的代价值)。感觉不是很合理，因为potarr值还是以dijkstra方法计算的，dist是欧式距离，但是potarr值没有将dist加进去。最终的效果感觉应该与dijkstra一样，可能需要自己去写代码或者在基础上去优化，也许我的问题看的不仔细，还需再看看代码。</p>]]></content>
      
      
      <categories>
          
          <category> 机器人路径规划算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> astar </tag>
            
            <tag> dijkstra </tag>
            
            <tag> 全局路径 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实体机器人相关问题与解决方案</title>
      <link href="/2023/10/19/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2023/10/19/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="740770ad648aed454bc28fbce54649df3c89a64c5392192bdf82dec2ff35ba07">7116ba464ba4898a8747743b1f1c7b02e5801057ebcdd3991c8c79431bd13b58494c4e63878bcea54cfddfb59ae6f52a6ba49dc1f1cc4deca2a401625748807476ecf905ffc200970375957ace90f6bb6c942ef5472c895b108a73c6e6621f73964766a28fd0b1ef175315676e1fd9bab36e3f267c79b57b40b4a0df6a046e7304737fa80ab0f8a7a52fb00cf9c40cceae5b8f67491899b643487f4717950374f3d1502a3d0f8ae1fb24bd236b1f2034dd1a178f6e481d120658d7215c43b000e9fdf5df36483384ec545b4760c293ef533ae7b18db6c4bc2455802340aedabf1454523f862e34ceba5d57197a99a44d5c3a4eabdbadfc7e8105ed75f8a88b95600ed93e1876fb9fdd0d6529f9e641966f935115c0a2d23f72039b235bfcb101ec85635215a575e9473a61343b49170ebe31d2b1d0fe69e52d9d9e6cd020ed05b14ca37acb7d63cb171d90e0a4bef95fae368ceaabf447e303d0482bb672cbdfa25d89d94ea9920a936f2639f82438b6d9ff32e062a917c0543ccccf14492f3203e6b39aceaabc0fa09e072f7656e2a8f8415c44ea9a35cb51abd512bcf941d4ecc522c7a29160cd0a5c0f59f802ab2f2ae65d052e6fbd08869406e40179101276ec2bb4094aa6a6ed8b1884f0fdcd23abb67f221a47f08fc4cc2e36c285a316f272eaa62baad32681044e66eeeb617de763cff81bfe66227ad3ad2af27a79480a414b4f28bae3f13cf3fa04afb2cd5d25422b1318d530ad0e2df68386f57933d52749258ece2a87ace011e4b6d6820f38b36a0a27f06c6abf2fcc0431ed41c4fb1a32cc4571c1e303d14897fea2966f04e25bae3a561dbc5fada24ff53c1abd4d4d9835cf2829b41b03cd624ad2512e595e4d31d94eeedd61c85978356b4ba3a3a134515090931420eb19ac0ef4e856dff6fe506fb29bb482b3bdd0f4660a646abe355396c781339c85331f2266e7b52d99ddb1c2ba543aee263f24ba30176d0c9a6e5337d1c44ab2ff96706d0bd895961687d9e6e705dec7b59b173bf9381e747fc15165ab61b47bce8161721a3608737dc19989883a36324597cc23c06948014d83eeb44a59aa64f2b58fafc6b5089ad8aade7f656232130f6912ef4d2757eb06bf3177cb679c7774600be79fb7ad6d4ff6fbf6251b7a89fd2666e76e551ec9ebd4a386847cdbad140efe6ec553d5cb083f0a7bf7858ae97d5741340c27b3bbd99a4e6352f6131b8439a5d276eaca6115e3deec20979f765a1bc4159ed8f33bd4909d97327a6b2cbf798de604ff3dce7efaf8ff55c1da1def49fd085d746c140ab785957a1f82ef266d8b69bc6ca867f679b855f6921e6f6277d5b2413e642ebe0887196d5329650dbed94b26536342b16489a3d02a52a11a14b5d0a67f31950225e7c5cdeeb81d40ef764717df53824491108079f71cd4c192557837abdb00c3c2e1a6c707ddd73652ebf74aa7985c6641089c7b4257fe1bc81c826bbcf9a252758a3177415caaeb63732dd430874c76bc40c8be416df287a8415657b16c586048b517045e2186687ca9dff0a5b774f684fc64d91cc2e60d40e79af58b858f943c15559aa2277d494fc0ff0d2e0dc5d8a0469575eb43b3e57be3db73ee090cba821272dee589572dc0aa6a416200742be40c9602d6458039506979c03e1661936d352e3b72d9ca1753c71d3857d5a1aa0b1f0c52f44ce457cb71e86972ee109638bfa2d226f628a67b9a8a067965c4128cbabf4213bc38613998add65a37a9eb9d811e3e5c50f0138093c4ae207db82792a5cc3add77a1ea29b6984fe14e5bd180446386a51f015b633df9b5de501f10b19bb390da325eae29eeb1032e73c02107097a7bcdc5c0916f44269ac309cfd4628d981effd3df2d563917cefc76f2d565eb62d25cab94b925d32255e4a76877eaccccdf7680ab88d69d3cd901dc66528eff55a4e9dc70e6c95df48f262345b4d0cdb7ffc4ee50da8f4315fd9cb2a02ca651f572080663e0af5254749f255178dee26aba9d8ff83506fe1ae28aa1668d1a3fa7d828d5bdf17d37c053f49b81c89334cec8859d4b21723a90fd45082efa67b3690e01aa875e53da3a61a24c6c7b736377e268024d8a82a8ba9dc976b097c8977562b256b6d3357e3feb2c844d86080f570daeb17d258c2f2c846129149f6faa218ff6d10bf973c24734b0e328ee9efd67033058b86684a7160d6e6cdda40a96868f3a611deb4706e17006795d4b5d3bfa18c844ffe4cf7e9d9a7ee85fe438374f3b2d68ccf70e455a599743ffb0d5aa0f7198104a9c41730e038f482e62dec7d92d93a566f060c9fc2edbecce792242a00a2eb6d0bd79bdc82c9008e8d92db8cbe2a08abf389185c1c533ca25d466066816ebf948c16238e177f3ebc6a84e59fffa74014a1b756427303650ce7cfb151ab4aa84dcf85106b4ff838a7b0e56cba36c55911f7854c5a9344a6fc728a5957e7c87f633be426342ce3cc3f3ffe19e4c752c5fb0e5e9d6d812ddd4c69c46393b0ec7e099bb0bc0b25f6e7cd45d20a9062c1e90390b8f2b59747d421edfa440aca2c2e1564316df68d1022e5e156a0383d91c48c2338a143735c2abd1885db8de6eaa3b5e31ef84732dee0594923fe11c7c4fc0c335b9323bf013d95d8597e89ef6e16fe24873cf6bcc1099f26d58136eb057ef34bf5835a8b57b55ac741e3d87506ecf16f8eaec34074c79c066655830cb61dce4fb6a6989c17d742a370fdb0b89b8027c6d1639cf2937a34db0977cb1bfd07e1d9901143e795655d66dba55dcf93a1e839b9063a28ccc017cf38909259f48bf9124d250b97cef987874603396b8eacdd6208362e210161a7f37e034c4c4ffa44a1d4022e3f9c68b84e4d5e67f1f4cd95b6dbc3881f4ea9a57bffd80dff8837c78d3bd705dcb5d95b2650fc688d14becaf8735e6f76b4f6d7b060f4070a04e1d1aa96104992a99d8a19c2505b3d3b06cc82ccfc5905361f30b7fa1d9b107596ece4c1ed70d9ce8cd9ca3186ad0114794a7a9f2e4f4e463fc574d3d9bdb67aff6c3b0c9ce1cf648103ec92d78b72975bf6b91f9883cecf2b49824734ad3527aa9fc74532b40bc55d8336043d23e807150d0ee945020afaff086333344f04084ffb824b81013dc821e47ac7e5d867fb29141c7f74c2a7d78640c25c827cac293659a79c282acc8eb54b0c4340f31932a2a6d1e755878935a0bfb6ffae4c4ab2e2c6c475b8bde364e83a2efb2e5cf1dfd258c426b9ab63d98b3e8c7d31b73f01f92a535b1984b63841931173a7d289ecdc8fb2384a13b0d6904c95e8ecddcdba04e0cf2c0779e3bb90dc8f57fa83f987784f18e7f9a70973173950708700493c7c1cf842b946fe70bf22b0fea38131cd963475e2810bc6416343a608d2d37c13b51589b625ec7778da2f81da87bf881545a86a9da06616b983f1b53aba9bb0dffe1bca57ef0f4e2dd1497cea6339908c395ee92ab14f8929d5eabe2fd7287f5cf940048722bfddc3c8a0fc618172b939a8a172e61c0e104c6f6685e8cf28bc65e1030ea9606000ecb9ad243af805a69d86dea070206ea9158bae0114a48cd823c853c14651654d9ffce042256a0e1eda5722b3a718cc1701c2363fbe05f2bf9760817ea5bae49650cef8ac27a26cb8c5d2dae01951e1618097b470702c20e5398255ba3b2cf3ebc412678fb56984ba5ebf7d3f6d34a1b92e69363641d6becf44bfc8492bb7d3ea7ac461e345d23c5be00f6cf5056dd8e91efa5696602af7359dc72571823b02fcad816dab69b0f14e3e52b1be3183419ce42ed96ce39d42c86271fa3dae0672167d859647cb5a917decc17974162e3179b1031480e059bd246c3ebc5a25c444c4bba195d0e30818f480d87de63331711bf5756675990f853b83cc0092b938f30613cf3b115ec3d70dc76c10b8fb8bc4076dc0b9ce173bd06fdfe7a5a33eab2e7690a67fc2185809da400032e3a911781487a5bcf2623d84b41c94af4edfeac391c369fbf2fa47b5470c6be9a7f75702577544b6bdd20a509a48eda69c333c269504068da1e5b684dbc26014298b6a114cc54f4a8dcf8938d791b99dfe1f4b046f3a7204db8266f503bf9490397eaec5a15b8574a4c17bff194f95142edcbba6f465a606abe2c06d37a6121de9581d938408d9026e0bb0e11b00ff46132227d60f906a5ee40b1edc117eb326d1089a64e2cc4801a5879138751b5b311870d75120837c3ed282d4b7174a07aadcec648e4f69e7f68abff695766bc1c8530e76d49ac8c9c23514af4cb7426ed66d17f5da40625380b43ee55bcfed9566e4f457a1fbe0b0e44b9585c97137b0c69d3cde0c2bc27585254885d9dbd0f2b93d066bd20539c30ca69f2bcd6aca34c7c8729508ea4b36b236ee41a55e6d744dbe681b46214114cd3c6a8defc2a07f5952e5aa84702216603e5dd65939b36d232070dbad433c2b6caae8ad0837c77126aa029052cd2b3f61df6adcce6b85333efac2f2cefda6d772318b98ba9e7844abfb34844058da05c91e43366d00f8c3b7ce3dc7aedc68953b410d1839ccad3cef1aa4bcd9f87332da0c41eb151b47bae954e064cb02702e2391de1242a7ad8535eadff4e2253f8ac1ffc89aa417841217a92218ed3ac50bf5807e745917326ab4515e46f1281fece9b7e43112172537d83deca3ef1c8169274ee665a7450ce13496da336b08e6de25be64aabc716e26341a5778c5c945e0490109da7fceb83de8c9e40394b1d0ff8a47a4d4e4caba24eb7ff223f69c97c29572ad619c8cc7ef485d1b23d58c9421580f7eb615cddabc86b005bd8f1c81ad170875bc39d8d2d1bf48e2d98f356fbdffbc66abc232adb6ebb413a661b2bfb79e5a384aac1d400d2d9fd8a4940b4492f3a5be5891ba84227e83e6c4e246a3deda07b7755e3c3c93e5d42522d7f5c3e89f6476a0604e0e5c78316f343ed30c0f9d691da071bec55fb86249ebfd6183528068684cd834b6b31536bfac4abb9e4bd6219b4d84a897e4196e05b2c35074b572d928b1759a68b6e17b100840f0f54ad9164f0798032c1767783b0d28fdb37d60886bd1f2e1b013fa5576fca1afa208765d2f7b4a258c4165054e012670cabf6c391a4b9eba4aa4c5caf92e3c880251effd4b8d48e0e88a13eceafbae1592b6dd52a78975403c8f7645f7777fcf33d3c837749901c2ce2d80bd37cf5fb30b7f13a64340a93af4d73e0fa81d8a5a5163bd5639fe1b329ab43662018d33599bdf56904aef5c883cd5f149019916a2a4ac160ad90dfc014a3bc347bff1e407c25b40c59fd0edce5f2f01e73d31c453bcb4fd1480b8e40c430d807952935a260d15aa24561ede7b31517edf5a7c9174ab7dce7a13c3755b1143cc42e664c46c559bc1a05ec6a9b518a5523f83224ec46923d526e4970ae6c18167b3332f68907aafb046842a43474113b787e42470fe85c4ae48e4afbc25c70b7323c767effe52c3c56ac7ac2bafcb513b93abd66caeeec49a26b2f96231921b006b9317137f34957554fc3a3bc3bff802243b2b1030c242fdd7d6d4c01450e255093a41255bff9471a36e53e5f24f912e4ddd4ccde07f8bdbfd91d05d13300ea5c8aa0a8a068ef07cfea0c74633a5c524025c59d7833843016a05b3bd68f0af225c7be483bce300d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">保密</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> ROS与机器人相关问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器人 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习-如何安装pytorch/yolov5</title>
      <link href="/2023/10/19/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85pytorch-yolov5/"/>
      <url>/2023/10/19/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85pytorch-yolov5/</url>
      
        <content type="html"><![CDATA[<h2 id="1创建虚拟环境pytorch和tensorflow安装"><a class="markdownIt-Anchor" href="#1创建虚拟环境pytorch和tensorflow安装"></a> 1.创建虚拟环境，pytorch和tensorflow安装</h2><p>每个项目所需库不一样，比如使用pytorch框架：<br />-&gt;打开 Anaconda prompt<br />-&gt;更换源，不然很慢<br />-&gt;创建环境<code>conda create --name pytorch python=3.7</code><br />-&gt;进入环境<code>conda activate pytorch</code><br />-&gt;下载pytorch：<code>conda install pytorch torchvision cpuonly</code>（删除-c pytorch，这样就可以使用镜像了,这里是下载cpu版本的，gpu根据自己配置修改）。tensorflow: <code>conda install tensorflow</code><br />-&gt;完成了，可以去pycharm创建新项目，然后打开python interpreter，选择previously，点击add interpreter，再去设置conda路径（看需求选择，我选择conda），然后interpreter选择创建的虚拟环境pytorch\tensorflow，然后ok，创建，最后就可以使用了<br />-&gt;如果要安装其他库，可以在 Anaconda prompt激活pytorch环境，然后conda install 包名。此时不用再添加镜像，因为前面已经修改了</p><h2 id="2anaconda创建新的python环境时报错an-unexpected-error-has-occurred-conda-has-prepared-the-above-report"><a class="markdownIt-Anchor" href="#2anaconda创建新的python环境时报错an-unexpected-error-has-occurred-conda-has-prepared-the-above-report"></a> 2.anaconda创建新的python环境时，报错’An unexpected error has occurred. Conda has prepared the above report’</h2><p>梯子没有关闭，关闭vpn即可，很多报错都与梯子有关，必须先关闭</p><h2 id="3在虚拟环境中安装第三方库"><a class="markdownIt-Anchor" href="#3在虚拟环境中安装第三方库"></a> 3.在虚拟环境中安装第三方库</h2><p>找到存放路径: ~/anaconda3/envs/pytorch/lib/python3.9/site-packages<br />比如安装opencv:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pip install --target=~/anaconda3/envs/pytorch/lib/python3.9/site-packages opencv-python -i https://pypi.tuna.tsinghua.edu.cn/simple/</span><br></pre></td></tr></table></figure><h2 id="4error-no-matching-distribution-found-for-ultralytics80100"><a class="markdownIt-Anchor" href="#4error-no-matching-distribution-found-for-ultralytics80100"></a> 4.ERROR: No matching distribution found for ultralytics&gt;=8.0.100</h2><p><code>pip install ultralytics --default-timeout=100 -i https://pypi.tuna.tsinghua.edu.cn/simple</code></p><h2 id="5yolov5实战"><a class="markdownIt-Anchor" href="#5yolov5实战"></a> 5.yolov5实战</h2><p>-&gt;安装ananconda：下载 <a href="http://Anaconda3-2022.05-Linux-aarch64.sh">Anaconda3-2022.05-Linux-aarch64.sh</a>；<code>bash Anaconda3-2022.05-Linux-aarch64.sh</code> 有时-u；加载新的PATH环境变量source ~/.bashrc ；<br />-&gt;创建yolo环境：<code>conda create -n yolo python=3.8</code>；激活<code>conda activate yolo</code><br />-&gt;安装yolov5:<code>git clone https://github.com/ultralytics/yolov5.git</code>；添加依赖：<code>pip3 install -U -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple</code><br />-&gt;测试：<code>conda activate yolo</code>-&gt;<code>python detect.py --source data/images/zidane.jpg</code><br />-&gt;测试电脑摄像头：找到detect.py文件，修改以下代码中的source：改成0则为调用电脑自带的摄像头；进入我们创建的yolo环境，输入python detect.py即可运行。<br />-&gt;将YOLOV5代码加入到ORB-SLAM2中</p><p>yolov5测试视频<br />-&gt;在data文件夹下创建video文件夹<br />-&gt;修改detect.py中的source：将/data/images修改为data/video</p><p>yolov5训练自己的数据：（准备好自己的数据集-&gt;借用权重文件训练自己的数据集-&gt;测试自己的验证集<br />-&gt;在yolov5同目录下创建数据集datasets，继续创建文件夹face做人脸识别<br />-&gt;在face下创建images数据集存放图片，可以写代码划分tarin和val，也可以自己随机划分<br />-&gt;在face下创建labels数据集存放标签，可以使用labeling去画框然后保存为txt文件<br />-&gt;在yolov5/data下创建yaml文件，可以参考coco128.yaml<br />-&gt;开始训练，进入pytorch环境，通过命令修改train.py的参数：<code>python train.py --weights yolov5s.pt --data data/face.yaml --workers 1 --batch-size 8</code><br />-&gt;训练完成后，将runs/exp/weights下的模型（<a href="http://best.pt">best.pt</a>）复制在yolov5文件夹下<br />-&gt;开始测试<code>python detect.py --weights best.pt --source ../datasets/face/images/val </code></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pytorch </tag>
            
            <tag> tensorflow </tag>
            
            <tag> yolov5 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
