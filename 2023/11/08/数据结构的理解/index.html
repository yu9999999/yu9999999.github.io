<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>数据结构与算法的理解 | 小鱼</title><meta name="author" content="小鱼"><meta name="copyright" content="小鱼"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数据结构 逻辑结构： 指数据元素之间逻辑关系的数据结构，这里的逻辑关系是指数据元素之间的前后间关系，与数据在计算机中的存储位置无关。 物理结构： 指数据的逻辑结构在计算机存储空间中的存放形式称为数据的物理结构，也叫做存储结构。  逻辑结构： 线性结构： 数据元素之间存在“一对一”的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的，线性结构是一个有序数据元素的集合。比如：一维数">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法的理解">
<meta property="og:url" content="http://uai86.cn/2023/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E7%90%86%E8%A7%A3/index.html">
<meta property="og:site_name" content="小鱼">
<meta property="og:description" content="数据结构 逻辑结构： 指数据元素之间逻辑关系的数据结构，这里的逻辑关系是指数据元素之间的前后间关系，与数据在计算机中的存储位置无关。 物理结构： 指数据的逻辑结构在计算机存储空间中的存放形式称为数据的物理结构，也叫做存储结构。  逻辑结构： 线性结构： 数据元素之间存在“一对一”的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的，线性结构是一个有序数据元素的集合。比如：一维数">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://uai86.cn/images/logo.jpg">
<meta property="article:published_time" content="2023-11-07T16:00:00.000Z">
<meta property="article:modified_time" content="2024-01-04T03:57:29.172Z">
<meta property="article:author" content="小鱼">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://uai86.cn/images/logo.jpg"><link rel="shortcut icon" href="/images/fav.jpg"><link rel="canonical" href="http://uai86.cn/2023/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E7%90%86%E8%A7%A3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构与算法的理解',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-04 11:57:29'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/logo.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: #bbcdc5"><nav id="nav"><span id="blog-info"><a href="/" title="小鱼"><span class="site-name">小鱼</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构与算法的理解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-11-07T16:00:00.000Z" title="发表于 2023-11-08 00:00:00">2023-11-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-04T03:57:29.172Z" title="更新于 2024-01-04 11:57:29">2024-01-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据结构与算法的理解"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> 数据结构</h1>
<p><strong>逻辑结构：</strong> 指数据元素之间逻辑关系的数据结构，这里的逻辑关系是指数据元素之间的前后间关系，与数据在计算机中的存储位置无关。<br />
<strong>物理结构：</strong> 指数据的逻辑结构在计算机存储空间中的存放形式称为数据的物理结构，也叫做存储结构。</p>
<h2 id="逻辑结构"><a class="markdownIt-Anchor" href="#逻辑结构"></a> 逻辑结构：</h2>
<p><strong>线性结构：</strong> 数据元素之间存在“一对一”的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的，线性结构是一个有序数据元素的集合。比如：一维数组、队列、链表、栈。<br />
<strong>非线性结构：</strong> 数据元素之间是一对多、多对一、多对多的关系。比如：树、堆、图、多维数组（相当于矩阵）。</p>
<h2 id="物理结构"><a class="markdownIt-Anchor" href="#物理结构"></a> 物理结构：</h2>
<p><strong>顺序存储：</strong> 用一组连续的存储单元依次存储数据元素，数据元素之间的逻辑关系由元素的存储位置来表示。比如：数组<br />
例子：(bat,cat,eat,……,mat)<br />
存储：</p>
<table>
<thead>
<tr>
<th style="text-align:center">…</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">bat</td>
</tr>
<tr>
<td style="text-align:center">cat</td>
</tr>
<tr>
<td style="text-align:center">eat</td>
</tr>
<tr>
<td style="text-align:center">…</td>
</tr>
</tbody>
</table>
<p><strong>链式存储：</strong> 用一组任意的储存单元储存数据元素，数据元素之间的逻辑关系用指针来表示。<br />
例子：(bat,cat,eat,……,mat)<br />
存储：</p>
<table>
<thead>
<tr>
<th style="text-align:center">元素索引</th>
<th style="text-align:center">元素</th>
<th style="text-align:center">下一个元素位置索引</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">130</td>
<td style="text-align:center">cat</td>
<td style="text-align:center">135</td>
</tr>
<tr>
<td style="text-align:center">135</td>
<td style="text-align:center">eat</td>
<td style="text-align:center">170</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
<tr>
<td style="text-align:center">头指针head-&gt; 165</td>
<td style="text-align:center">bat</td>
<td style="text-align:center">130 -&gt;下个元素在130号，130单元找到cat</td>
</tr>
<tr>
<td style="text-align:center">170</td>
<td style="text-align:center">mat</td>
<td style="text-align:center">Null -&gt;最后一个元素下一个元素没有了为空</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
</tbody>
</table>
<p><strong>索引存储：</strong> 在储存结点信息同时，还建立附加的索引表。比如手机通讯录，我们可以在手机通讯录上找到一个人名（这里人名就是索引index），点开这个人名，里面就会出现这个人的详细信息（这些信息就是储存的数据）。<br />
<strong>散列（或哈希）存储：</strong> 根据结点的关键字直接计算出该结点的储存地址。</p>
<h2 id="常用8种数据结构"><a class="markdownIt-Anchor" href="#常用8种数据结构"></a> 常用8种数据结构</h2>
<p><strong>数组（Array）</strong> 数组是一种线性结构，而且在物理内存中也占据着一块连续空间。直接通过索引来访问特定的元素，时间复杂度（O(1)）。如果你想在数组的中间插入一个元素，你需要将插入点之后的元素向后移动一位，这需要O(n)的时间复杂度。同样，删除元素也需要将删除点之后的元素向前移动一位，这也需要O(n)的时间复杂度。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//定义并初始化数组</span><br><span class="line">int a[] = &#123;1, 3, 5, 4, 6, 7&#125;;</span><br><span class="line">//访问特定元素并赋值给x</span><br><span class="line">x = a[1];</span><br><span class="line">//删除数字5</span><br><span class="line"><span class="keyword">for</span>(int i = 2; i &lt; 6; i++)&#123;</span><br><span class="line">  a[i] = a[i+1];</span><br><span class="line">&#125;</span><br><span class="line">//假设上面没有操作，还是调用初始数组，在5后面添加一个数字2</span><br><span class="line"><span class="keyword">for</span>(int i = 6; i &gt;= 3; i--)&#123;</span><br><span class="line">  a[i] = a[i-1];</span><br><span class="line">&#125;</span><br><span class="line">a[3] = 2;</span><br><span class="line">//修改5为2</span><br><span class="line">a[2] = 2;</span><br><span class="line">//c++其他数组模板，也可以理解为类</span><br><span class="line">array&lt;int, 5&gt; arr = &#123; 1, 2, 3, 4, 5 &#125;; //有固定大小</span><br><span class="line">vector&lt;int&gt; arr = &#123;1, 2, 3, 4, 5 &#125;;    //可以没有固定大小</span><br><span class="line">valarray&lt;int&gt; arr = &#123; 1, 2, 3, 4, 5 &#125;; //有固定大小</span><br></pre></td></tr></table></figure>
<p><strong>链表（Linked List）</strong> 链表是物理存储单元上非连续的、非顺序的存储结构，数据元素的逻辑顺序是通过链表的指针地址实现，每个元素包含两个结点，一个是存储元素的数据域 (内存空间)，另一个是指向下一个结点地址的指针域。在链表中，每个元素（称为节点）都包含一个数据部分和一个指向下一个节点的指针。这种结构允许我们在常数时间复杂度（O(1)）下插入和删除节点，因为这仅仅涉及到改变一些指针的指向。然而，随机访问链表中的元素需要从链表的头部开始，沿着指针找到目标元素。由于链表不是连续存储的，我们需要遍历链表，直到找到目标元素。因此，随机访问链表中的元素的时间复杂度是O(n)。这里再继续说一下单链表与双链表，单链表只能通过前一个节点next找到下一个节点，而双链表还可以通过后一个节点prev找到前一个节点。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//单链表</span><br><span class="line">forward_list&lt;int&gt; fl&#123; 1,2,3 &#125;;</span><br><span class="line">//双链表</span><br><span class="line">list&lt;int&gt; l;</span><br><span class="line">// 使用迭代器遍历列表中的元素  </span><br><span class="line"><span class="keyword">for</span> (auto it = l.begin(); it != l.end(); ++it) &#123;  </span><br><span class="line">    std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;  </span><br><span class="line">&#125; 	</span><br></pre></td></tr></table></figure>
<p><strong>队列（Queue）</strong> 队列中的添加和删除数据的操作分别是在两端进行的。队列可以在一端添加元素，在另一端取出元素，也就是：先进先出。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//队列，只能从队首删除元素，队尾插入元素</span><br><span class="line">queue&lt;int&gt;q;  //如果需要访问其他元素，需要不断删除队首元素(pop操作，如果只是遍历保持队列不变，可以在pop前进行push(q.front())操作)</span><br><span class="line">//优先队列，后面的堆将详细介绍</span><br><span class="line">priority_queue&lt;int&gt;pq;</span><br><span class="line">//双端队列，在队首和队尾都可以进行添加删除操作</span><br><span class="line">deque&lt;int&gt;dq;</span><br></pre></td></tr></table></figure>
<p><strong>栈（Stack）</strong> 栈也是一种数据呈线性排列的数据结构，不过在这种结构中，我们只能访问最新添加的数据。从栈顶放入元素的操作叫入栈，取出元素叫出栈。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//c++模板</span><br><span class="line">stack&lt;int&gt; q;</span><br></pre></td></tr></table></figure>
<p><strong>树（Tree）</strong> 它是由n（n&gt;=1）个有限节点组成一个具有层次关系的集合。把它叫做 “树” 是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。<br />
<strong>散列表（Hash）</strong> 哈希表，也叫散列表，是根据关键码和值 (key和value) 直接进行访问的数据结构，通过key和value来映射到集合中的一个位置，这样就可以很快找到集合中的对应元素。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//unordered_map可以理解为无序映射</span><br><span class="line">unordered_map&lt;string, int&gt; mymap;</span><br><span class="line">mymap[<span class="string">&quot;apple&quot;</span>] = 1; //数组形式插入</span><br><span class="line">pair&lt;string, int&gt; mypair(&#123;<span class="string">&quot;banana&quot;</span>, 2&#125;); //复制插入</span><br><span class="line">mymap.insert(mypair);</span><br><span class="line">mymap.insert(make_pair(<span class="string">&quot;cat&quot;</span>, 3)); //移动插入</span><br><span class="line">mymap.insert(&#123;&#123;<span class="string">&quot;dog&quot;</span>,4&#125;, &#123;<span class="string">&quot;egg&quot;</span>,5&#125;&#125;); //初始化数组插入，可以一次性插入多个</span><br><span class="line">unordered_map&lt;string, int&gt; middle = &#123;&#123;<span class="string">&quot;fat&quot;</span>,6&#125;, &#123;<span class="string">&quot;great&quot;</span>, 7&#125;&#125;; //范围插入</span><br><span class="line">mymap.insert(middle.begin(), middle.end());</span><br><span class="line"><span class="keyword">for</span> (auto&amp; x : mymap)  //输出</span><br><span class="line">      cout&lt;&lt;<span class="string">x.first&lt;&lt;&quot; : &quot;&lt;&lt;x</span>.second&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">//map可以理解为有序映射</span></span><br><span class="line"><span class="string">map&lt;string, int&gt; mymap;</span></span><br></pre></td></tr></table></figure>
<p><strong>堆（Heap）</strong> 堆是一种图的树形结构，被用于实现“优先队列”(priority queues)。优先队列是一种数据结构，可以自由添加数据，但取出数据时要从最小值开始按顺序取出。在堆的树形结构中，各个顶点被称为“结点”(node)，数据就存储在这些结点中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//不写后面两个参数默认为vector，less</span><br><span class="line">priority_queue&lt;int&gt; pq1;</span><br><span class="line">//建立一个优先级队列(大堆)，数据类型是int，利用vector容器实现，less（降序）实现</span><br><span class="line">priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; pq2;</span><br><span class="line">//建立一个优先级队列(小堆)，数据类型是int，利用vector容器实现，greater（降序）实现</span><br><span class="line">priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq3;</span><br></pre></td></tr></table></figure>
<p><strong>图（Graph）</strong> 图是由结点的有穷集合V和边的集合E组成。其中，为了与树形结构加以区别，在图结构中常常将结点称为顶点，边是顶点的有序偶对，若两个顶点之间存在一条边，就表示这两个顶点具有相邻关系。个人认为树可以理解成特殊的有向图，因为树中的边都是父节点与子节点的有向传递（如果该关系定义为1，则所有的边都是一条权重为1的有向边）。</p>
<h1 id="算法"><a class="markdownIt-Anchor" href="#算法"></a> 算法</h1>
<p>简单例子看一下普通循环与递归思想</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void PrintN(int N)&#123;</span><br><span class="line">    int i;</span><br><span class="line">    <span class="keyword">for</span>(i=1;i&lt;=N;i++)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;%d&quot;</span> &lt;&lt; <span class="string">i &lt;&lt; endl;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">//递归</span></span><br><span class="line"><span class="string">void PrintN(int N)&#123;</span></span><br><span class="line"><span class="string">    if(N)&#123;</span></span><br><span class="line"><span class="string">        PrintN(n-1);</span></span><br><span class="line"><span class="string">        cout &lt;&lt; &quot;%d&quot; &lt;&lt; N &lt;&lt; endl;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="排序算法"><a class="markdownIt-Anchor" href="#排序算法"></a> 排序算法</h2>
<p><strong>冒泡排序：</strong> 两个相邻数比较，排序错误就交换位置。由于算法复杂度较高，适合小数据的排序，在数据量大的时候不适合使用。时间：O(n<sup>2</sup>)，空间：O(1)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void BubbleSort(int a[], int n) &#123;</span><br><span class="line">    int tmp = 0;</span><br><span class="line">    <span class="keyword">for</span> (int i = n - 1; i &gt; 0; i--) &#123; </span><br><span class="line">        //两个相邻数比较后判断是否交换，目的是将位置在[0,i]范围内的最大值放在位置i。eg: 5 3 2 6 4 -&gt; 3 2 5 4 6</span><br><span class="line">        <span class="keyword">for</span> (int j = 0; j &lt; i; j++) &#123;        </span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[j + 1]) &#123;</span><br><span class="line">                tmp = a[j];</span><br><span class="line">                a[j] = a[j + 1];</span><br><span class="line">                a[j + 1] = tmp;</span><br><span class="line">                //swap(a[j], a[j+1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>选择排序：</strong> 从头开始，找到最小值放在开头，然后找第二小的值放在后面，以此类推。适用于简单数据排序。时间：O(n<sup>2</sup>)，空间：O(1)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void SelectionSort(int a[], int n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (int i = 0; i &lt; n - 1; i++) &#123;</span><br><span class="line">        int min = i;</span><br><span class="line">        //找位置在[i,n-1]范围的最小值</span><br><span class="line">        <span class="keyword">for</span> (int j = i + 1; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[min])</span><br><span class="line">                min = j;</span><br><span class="line">        &#125;</span><br><span class="line">        //交换位置，将第i小的值放在位置i</span><br><span class="line">        swap(a[min], a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>插入排序：</strong> 先将前两个数排序，然后再将第三个数与前两个数比较排序，当前n-1个数排好序后，再将第n个数从n-1的位置开始比较，如果排序错误就交换，以此往前走。适用于数据比较少的时候，一般做为快速排序的扩充。时间：O(n<sup>2</sup>)，空间：O(1)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void InsertionSort(int a[], int n)&#123;</span><br><span class="line">    //前i个数排好序了，再将第i+1个数插入进去，则前i+1个数就排好序了</span><br><span class="line">    <span class="keyword">for</span>(int i = 1; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt; a[i-1])&#123;</span><br><span class="line">            int j = i - 1;</span><br><span class="line">            int tmp = a[i];    //找到a[i]应该插入的位置，再将其插入进去，同时该右移的数右移一步</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= 0 &amp;&amp; tmp &lt; a[j])&#123;</span><br><span class="line">                a[j+1] = a[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            a[j+1] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>归并排序：</strong> 将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。归并排序在数据量比较大的时候也有较为出色的表现（效率上），但是，其空间复杂度O(n)使得在数据量特别大的时候（例如，1千万数据）几乎不可接受。时间：O(nlogn)，空间：O(n)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void Merge(int a[], int low, int mid, int high)  //合并函数。还是下面得例子：merge(a, 0, 1, 3)</span><br><span class="line">&#123;</span><br><span class="line">	int* b = new int[high - low + 1];  </span><br><span class="line">	int i = low, j = mid + 1, k = 0;   </span><br><span class="line">    //第一个<span class="keyword">while</span>是将左边排好序得数组a[i]和右边排好序得数组a[j]进行比较，并将较小的元素放在数组b中，相应的指针向后移动，直到i&gt;mid或者j&gt;high时结束。</span><br><span class="line">    //1.a[0]与a[2]比较，得到b[0]=a[2]=5；2.将a[0]与a[3]比较，得到b[1]=a[0]=15；3.将a[1]与a[3]比较，得到b[2]=a[3]=25 </span><br><span class="line">	<span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high)&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i] &lt;= a[j])</span><br><span class="line">			b[k++] = a[i++];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			b[k++] = a[j++];</span><br><span class="line">	&#125;</span><br><span class="line">    //由于第一个<span class="keyword">while</span>已经将左右数组其中一个数组得所有元素比较完了（假设左边数组比较完了），所以第三个<span class="keyword">while</span>就是将右边数组直接赋值给b，因为本身是排好序的；否则第二个<span class="keyword">while</span>将左边数组赋值给b。</span><br><span class="line">    //4.由于j=4,i=1，所以最后将a[1]赋值给b[3]</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= mid)&#123;</span><br><span class="line">		b[k++] = a[i++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (j &lt;= high)&#123;</span><br><span class="line">		b[k++] = a[j++];</span><br><span class="line">	&#125;</span><br><span class="line">    //5.将排好序的b赋值给a</span><br><span class="line">	k = 0;  </span><br><span class="line">	<span class="keyword">for</span> (int i = low; i &lt;= high; i++)&#123;</span><br><span class="line">		a[i] = b[k++];</span><br><span class="line">	&#125;</span><br><span class="line">	delete[]b;  </span><br><span class="line">&#125;</span><br><span class="line">//归并排序。注意这里的hign不是前面经常出现的n哦，hign=n-1,就是元素个数减一</span><br><span class="line">void MergeSort(int a[], int low, int high) </span><br><span class="line">//eg:40 15 25 5，low=0，high=3；</span><br><span class="line">//先mergesort(a, 0, 1)计算得：a[0]=15,a[1]=40（中间计算还要经过mergesort(a, 0, 0)，mergesort(a, 1, 1)，merge(a, 0, 0, 1)才得出来的，这里省略了）;</span><br><span class="line">//然后mergesort(a, 2, 3)计算得：a[2]=5,a[3]=25;</span><br><span class="line">//最后merge(a, 0, 1, 3)计算得：a[0]=5,a[1]=15,a[2]=25,a[3]=40。</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (low &lt; high)&#123;</span><br><span class="line">		int mid = (low + high) / 2;</span><br><span class="line">		MergeSort(a, low, mid);           </span><br><span class="line">		MergeSort(a, mid + 1, high);   </span><br><span class="line">		Merge(a, low, mid, high);       </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>快速排序：</strong> 1.选取元素的第一个元素作为基准元素；2.从右向左扫描，找到小于等于 pivot 的数，如果找到，将其放置左侧；3.从左向右扫描，找到大于 pivot 的数，如果找到，将其放置右侧；4.重复 步骤二~步骤三，直到 j 与 i 的指针重合，将其作为基准位置返回；5.经过前面步骤，基准左侧值都比基准元素小，右侧都比基准元素大，此时用同样的方法分别将左侧与右侧元素排序。快速排序在大多数情况下都是适用的，尤其在数据量大的时候性能优越性更加明显。时间：O(nlogn)，空间：O(logn)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void QuickSort(int a[],int low,int high)  //eg:32，25，5，56，17，33</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &gt;= high) <span class="built_in">return</span>;</span><br><span class="line">    int i = low;</span><br><span class="line">    int j = high;</span><br><span class="line">    int key = a[low];</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; key &lt; a[j]) j--;//1.从右向左找比基准元素（32）小的值,找到17,此时j=4</span><br><span class="line">        a[i] = a[j];                    //2.a[0]=a[4]=17       此时 17 25 5 56 17 33</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; key &gt; a[i]) i++;//3.从左向右找比基准元素（32）大的值,找到56，此时i=3</span><br><span class="line">        a[j] = a[i];                   //4.a[4]=a[3]=56        此时17 25 5 56 56 33</span><br><span class="line">    &#125;</span><br><span class="line">    a[i] = key;                       //5.a[3]=32              此时 17 25 32 56 33</span><br><span class="line">    QuickSort(a, low, i-1);  //左边子序列递归排序，用上面的方法对 17 25排序</span><br><span class="line">    QuickSort(a, i+1, high); //右边子序列递归排序，用上面的方法对 56 33排序</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>堆排序：</strong> 堆排序在建立堆和调整堆的过程中会产生比较大的开销，在元素少的时候并不适用。但是，在元素比较多的情况下，还是不错的一个选择。尤其是在解决诸如“前n大的数”一类问题时，几乎是首选算法。时间：O(nlogn)，空间：O(1)。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//最大堆，start是父节点位置，end是最后位置</span><br><span class="line">void Maxheapdown(int a[], int start, int end) //该函数返回父节点、左孩、右孩中最大的值</span><br><span class="line">&#123;</span><br><span class="line">    //建立父节点指标和子节点指标</span><br><span class="line">    int dad = start;</span><br><span class="line">    int son = dad * 2 + 1;  //当前是左孩，比较后更新为孩子中最大值</span><br><span class="line">    <span class="keyword">while</span> (son &lt;= end)&#123; //若子节点指标在范围内才做比较</span><br><span class="line">        <span class="keyword">if</span> (son + 1 &lt;= end &amp;&amp; a[son] &lt; a[son + 1]) //先比较两个子节点大小，选择最大的</span><br><span class="line">            son++;</span><br><span class="line">        <span class="keyword">if</span> (a[dad] &gt; a[son]) //如果父节点大于子节点代表调整完毕，直接跳出函数</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;              //否则交换父子内容再继续子节点和孙节点比较</span><br><span class="line">            swap(a[dad], a[son]);</span><br><span class="line">            dad = son;</span><br><span class="line">            son = dad * 2 + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//堆排序(从小到大)，对数组a进行升序排序，n是数组个数</span><br><span class="line">void HeapSort(int a[], int n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (int i = n / 2 - 1; i &gt;= 0; i--)&#123;   //构造最大堆，数组顺序就是从上到下，从左到右</span><br><span class="line">        Maxheapdown(a, i, n-1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (int i = n - 1; i &gt; 0; i--)&#123;       //最大堆排序方式</span><br><span class="line">        swap(a[0], a[i]);                  //交换元素，将最大元素放在数组最后面，每次交换后都是前面最大值</span><br><span class="line">        Maxheapdown(a, 0, i-1);            //调整最大堆，上一个<span class="keyword">for</span>很多都调整好了，所以这里只调整根节点那里</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**希尔排序：**1.对于n个待排序的数列，取一个小于n的整数gap(gap被称为步长)将待排序元素分成若干个组子序列，所有距离为gap的倍数的记录放在同一个组中。2.对各组内的元素进行直接插入排序（ 这一趟排序完成之后，每一个组的元素都是有序的）。3.减小gap的值，并重复执行上述的分组和排序。4.重复这样的操作，当gap=1时，整个数列就是有序的。希尔排序没有快速排序快 ，在中等大小规模表现良好，希尔算法在最坏的情况下和平均情况下执行效率相差不是很多，与此同时快速排序在最坏的情况下执行的效率会非常差。时间复杂度与步长相关。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void ShellSort(int a[], int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i,j,gap;</span><br><span class="line">    // gap为步长，每次减为原来的一半。</span><br><span class="line">    <span class="keyword">for</span> (gap = n / 2; gap &gt; 0; gap /= 2)&#123;</span><br><span class="line">        <span class="keyword">for</span> (i = 0 ;i &lt; gap; i++)&#123;                //分为gap组</span><br><span class="line">            <span class="keyword">for</span> (j = i + gap; j &lt; n; j += gap)&#123;   //每组排序，就是插入排序的思想，先将前面排好序，后面的插入进来排序</span><br><span class="line">                <span class="keyword">if</span> (a[j] &lt; a[j - gap])&#123;</span><br><span class="line">                    int tmp = a[j];</span><br><span class="line">                    int k = j - gap;</span><br><span class="line">                    <span class="keyword">while</span> (k &gt;= 0 &amp;&amp; a[k] &gt; tmp)&#123;//比如：2 4 8 3，如果没有<span class="keyword">while</span>则结果为2 4 3 8，有<span class="keyword">while</span>结果为2 3 4 8</span><br><span class="line">                        a[k + gap] = a[k];</span><br><span class="line">                        k -= gap;</span><br><span class="line">                    &#125;</span><br><span class="line">                    a[k + gap] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**计数排序：**1.找到数据范围；2.计算数据个数；3.依次排序。计数排序只适用于数据范围较集中的序列的排序，若待排序列的数据较分散，则会造成空间浪费，并且计数排序只适用于整型排序，不适用与浮点型排序。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//eg: 3 5 8 1 2 2 6 5 4 3 1 2 6 8 5 4</span><br><span class="line">void CountSort(int a[], int n)</span><br><span class="line">&#123;</span><br><span class="line">	//1.首先找出最大值与最小值,max=8,min=1</span><br><span class="line">	int min = a[0];</span><br><span class="line">	int max = a[0];</span><br><span class="line">	<span class="keyword">for</span> (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i] &gt; max)</span><br><span class="line">			max = a[i];</span><br><span class="line">		<span class="keyword">if</span> (a[i] &lt; min)</span><br><span class="line">			min = a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	//2.开辟内存，range=7+1=8,则count初始化为&#123;0,0,0,0,0,0,0,0&#125;代表0的个数为0，1的个数为0，2的个数为0，3的个数为0，4的个数为0，5的个数为0，6的个数为0，7的个数为0</span><br><span class="line">	int range = max - min + 1;</span><br><span class="line">	vector&lt;int&gt;  count(range, 0);</span><br><span class="line">	//3.统计相同元素出现次数，<span class="keyword">for</span>完过后，count=&#123;2，3，2，2，3，2，0，2&#125;</span><br><span class="line">	<span class="keyword">for</span> (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">		count[a[i] - min]++;</span><br><span class="line">	&#125;</span><br><span class="line">	//4.排序</span><br><span class="line">	int k = 0;</span><br><span class="line">	<span class="keyword">for</span> (int j = 0; j &lt; range; j++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(int m = 0; m &lt; count[j]; m++)&#123;</span><br><span class="line">			a[k++] = j + min;  //a[0]=1,a[1]=1，然后退出<span class="keyword">while</span>，进入<span class="keyword">for</span>，可以得到a[3]=2,a[4]=2,a[5]=2，再退出<span class="keyword">while</span>，一直下去</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**桶排序：**1.确定元素范围，以及桶的个数；2.将元素放入桶中，在哪个范围放入哪个桶；3.对每个桶排序；4.最后按桶的顺序就排好序了。他的时间复杂度与排序方式有关。这里只看看桶间排序的思想，桶内排序直接使用上诉算法就行了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void BucketSort(int a[], int n)&#123;</span><br><span class="line">    //1.将元素装入桶中</span><br><span class="line">    vector&lt;int&gt; buckets[10];              //假设定义10个桶，桶的个数竟然与元素个数n一样，实际桶的个数应该是元素最大值/size</span><br><span class="line">    int size = 2;                         //一个桶与另一个桶的间隔</span><br><span class="line">    <span class="keyword">for</span> (int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">        int idx = a[i] / size;            //可以计算出a[i]元素属于哪个桶的索引。注意：因为这里直接除以size，所以元素都是&gt;=0的，[0,size-1]属于桶0，[size,2size-1]属于桶1，……</span><br><span class="line">        buckets[idx].push_back(a[i]);     //入桶</span><br><span class="line">    &#125;</span><br><span class="line">    //2.桶内无序，桶间有序，如果需要排好序，可以调用上面的排序算法进行桶间排序</span><br><span class="line">    int l = 0;</span><br><span class="line">    <span class="keyword">for</span> (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (int j = 0; j &lt; buckets[i].size(); j++) &#123;</span><br><span class="line">            a[l++] = buckets[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**基数排序：**首先将所有待比较数字统一为统一位数长度，接着从最低位开始，依次进行排序。排序后，数列就变成了一个有序序列。这里用了桶排序的思想，因为每次排序都只需要10个桶。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void RadixSort(int a[], int n, int max)</span><br><span class="line">&#123;</span><br><span class="line">    //1.计算最大数的位数</span><br><span class="line">    int d = 1;</span><br><span class="line">    <span class="keyword">while</span> (max) &#123;</span><br><span class="line">        ++d;</span><br><span class="line">        max /= 10;</span><br><span class="line">    &#125;</span><br><span class="line">    //2.d位数就进行d次排序，每次都用桶排序，只需要桶间有序就可以了，桶内无序没关系</span><br><span class="line">    vector&lt;int&gt; buckets[10];   //数字是0-9，所以需要10个桶</span><br><span class="line">    int radix = 1;             //radix=1是个位数排序，radix=10是十位数排序，以此类推</span><br><span class="line">    int m;                     //桶的索引</span><br><span class="line">    <span class="keyword">for</span> (int i = 1; i &lt;= d; i++)</span><br><span class="line">    &#123; </span><br><span class="line">        int z = 0;                 //数组排序索引</span><br><span class="line">        //入桶</span><br><span class="line">        <span class="keyword">for</span> (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">            m = (a[j] / radix) % 10;</span><br><span class="line">            buckets[m].push_back(a[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        //桶间排序就够了</span><br><span class="line">        <span class="keyword">for</span> (int k = 0; k &lt; 10; k++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (int l = 0; l &lt; buckets[k].size(); l++) &#123;</span><br><span class="line">                a[z++] = buckets[k][l];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        radix = radix * 10;</span><br><span class="line">        //每次排序完清空桶</span><br><span class="line">        <span class="keyword">for</span> (int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">            buckets[i].clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查找算法"><a class="markdownIt-Anchor" href="#查找算法"></a> 查找算法</h2>
<p><strong>顺序查找：</strong> 对于任意一个序列，从一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，若相等则表示查找成功；若扫描结束仍没有找到关键字等于k的结点，表示查找失败。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int SequentialSearch(int a[], int n, int key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (int i = 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == key)</span><br><span class="line">            <span class="built_in">return</span> i;      //返回位置i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> -1;             //没找到</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>二分查找：</strong> 1.确定查找范围low=0，high=N-1，计算中项mid=（low+high）/2。2.若mid==x或low&gt;=high,则结束查找；否则，向下继续。3.若<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>m</mi><mi>i</mi><mi>d</mi><mo>&lt;</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">amid&lt;x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span><span class="mrel">&lt;</span><span class="mord mathit">x</span></span></span></span>,说明待查找的元素值只可能在比中项元素大的范围内，则把mid+1的值赋给low，并重新计算mid，转去执行步骤2；若<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi><mo>&gt;</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">mid&gt;x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span><span class="mrel">&gt;</span><span class="mord mathit">x</span></span></span></span>，说明待查找的元素值只可能在比中项元素小的范围内，则把mid-1的值赋给high，并重新计算mid，转去执行步骤2。(注：必须先排好序)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int BinarySearch(int a[], int n, int key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == NULL || n == 0)</span><br><span class="line">        <span class="built_in">return</span> -1;</span><br><span class="line">    int low = 0;</span><br><span class="line">    int high = n - 1;</span><br><span class="line">    int mid = 0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (low + high) / 2;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &lt; key)</span><br><span class="line">            low = mid + 1;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &gt; key)</span><br><span class="line">            high = mid - 1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>插值查找：</strong> 类似于二分查找思想，只是计算mid方式不同。mid=low+(key-a[low])/(a[high]-a[low])*(high-low)  （注：仍然有序）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int InterpolationSearch(int a[], int n, int key) &#123;</span><br><span class="line">	int left = 0;</span><br><span class="line">	int right = n - 1;</span><br><span class="line">	int mid;</span><br><span class="line">	// 终止条件</span><br><span class="line">	<span class="keyword">while</span> (left &lt; right)</span><br><span class="line">	&#123;</span><br><span class="line">		// 中间位置计算</span><br><span class="line">		mid = left + int((key - a[left]) / (a[right] - a[left]) * (right - left));</span><br><span class="line">		<span class="keyword">if</span> (a[mid] == key) &#123;</span><br><span class="line">			<span class="built_in">return</span> mid;</span><br><span class="line">		&#125;</span><br><span class="line">		// 目标值在中间值右边，更新左位置</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; key) &#123;</span><br><span class="line">			left = mid + 1;</span><br><span class="line">		&#125;</span><br><span class="line">		// 目标值在中间值左边，更新右位置</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			right = mid - 1;</span><br><span class="line">	&#125;</span><br><span class="line">	// 只剩最后一个元素时</span><br><span class="line">	<span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">		<span class="keyword">if</span> (key == a[left]) &#123;</span><br><span class="line">			<span class="built_in">return</span> left;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>斐波那契查找：</strong> 也是二分查找的一种提升算法，通过运用黄金比例的概念在数列中选择查找点进行查找，斐波那契数列：{1, 1, 2, 3, 5, 8, 13, 21, 34, 55，……}。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//斐波那契数列，a[n]=a[n-1]+a[n-2]，这里就是求第n个数的值a[n]=f</span><br><span class="line">int Fibonacci(int n)</span><br><span class="line">&#123;</span><br><span class="line">	int f = 0, g = 1;</span><br><span class="line">	<span class="keyword">while</span> (n--)</span><br><span class="line">	&#123;</span><br><span class="line">		g += f;</span><br><span class="line">		f = g - f;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line">//eg:1,5,7,12,15,25,84,86,92,99   查找12</span><br><span class="line">int FibonacciSearch(int* a, int n, int key)</span><br><span class="line">&#123;</span><br><span class="line">	int low = 1, high = n, mid, i, k = 0;</span><br><span class="line">	<span class="keyword">while</span> (n &gt; Fibonacci(k) - 1)k++;                   //1. n=10，则k=7</span><br><span class="line">	<span class="keyword">for</span> (i = n; i &lt; Fibonacci(k) - 1; i++)a[i] = a[n]; //2. a[10]=a[11]=a[9]=99</span><br><span class="line">	<span class="keyword">while</span> (low &lt;= high)</span><br><span class="line">	&#123;</span><br><span class="line">		mid = low + Fibonacci(k - 1) - 1;         //3.k=6,mid=8,a[8]=92 5.k=4,mid=3,a[3]=12</span><br><span class="line">		<span class="keyword">if</span> (key &lt; a[mid])</span><br><span class="line">		&#123;</span><br><span class="line">			high = mid - 1;                  //4.high=7,k=5</span><br><span class="line">			k -= 1;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (key &gt; a[mid])</span><br><span class="line">		&#123;</span><br><span class="line">			low = mid + 1;</span><br><span class="line">			k -= 2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (mid &lt;= n)<span class="built_in">return</span> mid;        //6.返回mid=3</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">return</span> n;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>分块查找：</strong> 将n个数据元素”按块有序”划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须”按块有序”；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，……。1、先选取各块中的最大关键字构成一个索引表；2、查找分两个部分：先对索引表进行二分查找或顺序查找，以确定待查记录在哪一块中；3、在已确定的块中用顺序法进行查找。（如果块内也有序的话，则所有元素都是排好序的，此时也就分成几等份，看查找元素在哪个区间而已）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">    int bockts_max;            //bockts_max为块内最大值 </span><br><span class="line">    int <span class="built_in">link</span>;                 //指向对应块的起始下标 </span><br><span class="line">&#125; IdxType;</span><br><span class="line">typedef IdxType IDX[100];   //索引表类型 </span><br><span class="line"></span><br><span class="line">int ChunkSearch(IDX I, int m, int a[], int n, int key)&#123;   </span><br><span class="line">    int low = 0, high = m - 1, mid, i;</span><br><span class="line">    int b = n / m;                        //b为每块的记录个数</span><br><span class="line">    //二分查找找属于的块</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high)     </span><br><span class="line">    &#123;</span><br><span class="line">        mid = (low + high) / 2;</span><br><span class="line">        <span class="keyword">if</span> (I[mid].bockts_max &gt;= key)</span><br><span class="line">            high = mid - 1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            low = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    //找到块后，从块的最小索引开始查找元素位置</span><br><span class="line">    i = I[high + 1].<span class="built_in">link</span>;           //I[high + 1].<span class="built_in">link</span>为块中的最小索引</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= I[high + 1].<span class="built_in">link</span> + b - 1 &amp;&amp; a[i] != key) //没找到，索引就加一。要么找到；要么直到索引进入下一个块，则认为没找到</span><br><span class="line">        i++;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= I[high + 1].<span class="built_in">link</span> + b - 1)</span><br><span class="line">        <span class="built_in">return</span> i;            //返回查找成功后该数值在数组中的索引</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br><span class="line">//下面就是举的例子</span><br><span class="line">int <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    IDX I = &#123; &#123; 14,0 &#125;,&#123; 34,5 &#125;,&#123; 66,10 &#125;,&#123; 85,15 &#125;,&#123; 100,20 &#125; &#125;;</span><br><span class="line">    int a[] = &#123; 8,14,6,9,10, 22,34,18,19,31, 40,38,54,66,46, 71,78,68,80,85, 100,94,88,96,87 &#125;;</span><br><span class="line">    int target = 5; </span><br><span class="line">    int index = ChunkSearch(I, 5, a, 25, 22);</span><br><span class="line">    <span class="keyword">if</span> (index != -1) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Target found at index &quot;</span> &lt;&lt; <span class="string">index &lt;&lt; endl;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    else &#123;</span></span><br><span class="line"><span class="string">        cout &lt;&lt; &quot;Target not found&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>树表查找：</strong><br />
<strong>散列表查找：</strong></p>
<h2 id="贪心算法"><a class="markdownIt-Anchor" href="#贪心算法"></a> 贪心算法</h2>
<p><strong>原理：</strong> 贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解。简单说，就是一个大问题分解成几个小问题，几个小问题的最优解的和就是大问题的最优解。举两个例子。<br />
**1.**dijkstar算法，但是该算法求解的最短距离不一定全局最优，因为走的下一个点并不是全局最优经过的点，或者说全局最优的点无法到达局部最优那个点（因为画成了小格子，所以一个点只能到达顶点，但是实际最短路线可能会经过边），举个例：在不考虑障碍物情形下，原点和终点在一个简单的3*4小格子的对角线上，用贪心算法算出来的最短距离为1+3sqrt(2)（这里用的欧氏距离，但是贪心算法必须到达一个顶点） ，实际全局最短距离为5，虽然不是全局最优，但是也算接近。但是如果原点和终点在同一边上，则贪心算法就是全局最优。<br />
**2.**钱币找零问题，假如有15元，需要用11、5、1三种面额的钱币来表示，如果用贪心算法来选择的话，会从11开始选择，这样就会选出一张11面额和4张1元面额的方案，但实际上，用3张5元面额的方案，使用的钱币更少，此时贪心方案就选不出全局最优解。</p>
<h2 id="暴力递归"><a class="markdownIt-Anchor" href="#暴力递归"></a> 暴力递归</h2>
<p><strong>青蛙问题：</strong> 一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 10 级的台阶总共有多少种跳法。<br />
<strong>思路：</strong> 要想跳到第10级台阶，要么是先跳到第9级，然后再跳1级台阶上去;要么是先跳到第8级，然后一次迈2级台阶上去，则f(10)=f(9)+(8)。以此类推。</p>
<h2 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h2>
<p><strong>原理：</strong> 若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量： 一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。 这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。类似暴力递归，但是这里用空间去换时间。<br />
<strong>青蛙问题思路：</strong> f(1)=1,f(2)=2,f(3)=f(1)+f(2)=3,……,f(n)=f(n-1)+f(n-2)。先储存f(1),f(2),算一个存一个，直到算出f(n)。<br />
<strong>背包问题：</strong> 假设我们有n种类型的物品，分别编号为1, 2…n。其中编号为i的物品价值为vi，它的重量为wi。为了简化问题，假定价值和重量都是整数值。现在，假设我们有一个背包，它能够承载的重量是Cap。现在，我们希望往包里装这些物品，使得包里装的物品价值最大化，那么我们该如何来选择装的东西呢？注意：每种物品只有一件，可以选择放或者不放。初始化数据为：n=5，w={2,2,6,5,4}，v={6,3,5,4,6}，Cap=10<br />
<strong>背包思路：</strong> f[i][j]=max(f[i-1][j],f[i-1][j-w[i]]+p[i])，i代表子问题，j代表承重，f(i)(j)代表第i个问题下满足承重j下的最优价值，w[i]为第i号物品的重量，p[i]为第i号物品的价值。比如：f[2][10],就是从2的个问题（1.2号物品中）找出承重量为3的最优价值，f[2][3]=max(f[1][3],f[1][1]+3)，这里要么选择前一个问题值，要么在满足承重条件下加上2号物品价值，两个选最大的就行了。<br />
<strong>分解的5个子问题：</strong> 1.从1号物品中分别找出背包承重[0，10]的最优解。2.从1.2号物品中分别找出背包承重[0，10]的最优解，很明显从4开始,最优解v=9。3.从1.2.3号物品中分别找出背包承重[0，10]的最优解。4.从1.2.3.4号物品中分别找出背包承重[0，10]的最优解。5.从1.2.3.4.5号物品中分别找出背包承重[0，10]的最优解。<br />
<strong>下表为每个子问题对应承重的最优解</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">子问题\承重</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
<th style="text-align:center">8</th>
<th style="text-align:center">9</th>
<th style="text-align:center">10</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">6</td>
<td style="text-align:center">6</td>
<td style="text-align:center">6</td>
<td style="text-align:center">6</td>
<td style="text-align:center">6</td>
<td style="text-align:center">6</td>
<td style="text-align:center">6</td>
<td style="text-align:center">6</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">6</td>
<td style="text-align:center">6</td>
<td style="text-align:center">9</td>
<td style="text-align:center">9</td>
<td style="text-align:center">9</td>
<td style="text-align:center">9</td>
<td style="text-align:center">9</td>
<td style="text-align:center">9</td>
<td style="text-align:center">9</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">6</td>
<td style="text-align:center">6</td>
<td style="text-align:center">9</td>
<td style="text-align:center">9</td>
<td style="text-align:center">9</td>
<td style="text-align:center">9</td>
<td style="text-align:center">11</td>
<td style="text-align:center">11</td>
<td style="text-align:center">14</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">6</td>
<td style="text-align:center">6</td>
<td style="text-align:center">9</td>
<td style="text-align:center">9</td>
<td style="text-align:center">9</td>
<td style="text-align:center">10</td>
<td style="text-align:center">11</td>
<td style="text-align:center">13</td>
<td style="text-align:center">14</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">6</td>
<td style="text-align:center">6</td>
<td style="text-align:center">9</td>
<td style="text-align:center">9</td>
<td style="text-align:center">12</td>
<td style="text-align:center">12</td>
<td style="text-align:center">15</td>
<td style="text-align:center">15</td>
<td style="text-align:center">15</td>
</tr>
</tbody>
</table>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://uai86.cn">小鱼</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://uai86.cn/2023/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E7%90%86%E8%A7%A3/">http://uai86.cn/2023/11/08/数据结构的理解/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://uai86.cn" target="_blank">小鱼</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post_share"><div class="social-share" data-image="/images/logo.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/11/10/C-%E5%85%AC%E6%9C%89%E3%80%81%E7%A7%81%E6%9C%89%E4%B8%8E%E4%BF%9D%E6%8A%A4/" title="C++"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++</div></div></a></div><div class="next-post pull-right"><a href="/2023/10/31/dwa%E7%AE%97%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3/" title="dwa算法的理解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">dwa算法的理解</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/logo.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">小鱼</div><div class="author-info__description">学无止境</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yu9999999/yu9999999.github.io/tree/master"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:zhanyu9786@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text"> 数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text"> 逻辑结构：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text"> 物理结构：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A88%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.</span> <span class="toc-text"> 常用8种数据结构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text"> 算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text"> 排序算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text"> 查找算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text"> 贪心算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9A%B4%E5%8A%9B%E9%80%92%E5%BD%92"><span class="toc-number">2.4.</span> <span class="toc-text"> 暴力递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">2.5.</span> <span class="toc-text"> 动态规划</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/05/%E4%B8%A4%E8%BD%AE%E5%B7%AE%E9%80%9F%E8%BF%90%E5%8A%A8%E5%AD%A6/" title="两轮差速运动学">两轮差速运动学</a><time datetime="2023-12-05T03:19:42.000Z" title="发表于 2023-12-05 11:19:42">2023-12-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/29/Teb%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81/" title="Teb原理与源码">Teb原理与源码</a><time datetime="2023-11-28T16:00:00.000Z" title="发表于 2023-11-29 00:00:00">2023-11-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/10/C-%E5%85%AC%E6%9C%89%E3%80%81%E7%A7%81%E6%9C%89%E4%B8%8E%E4%BF%9D%E6%8A%A4/" title="C++">C++</a><time datetime="2023-11-09T16:00:00.000Z" title="发表于 2023-11-10 00:00:00">2023-11-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E7%90%86%E8%A7%A3/" title="数据结构与算法的理解">数据结构与算法的理解</a><time datetime="2023-11-07T16:00:00.000Z" title="发表于 2023-11-08 00:00:00">2023-11-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/31/dwa%E7%AE%97%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3/" title="dwa算法的理解">dwa算法的理解</a><time datetime="2023-10-30T16:00:00.000Z" title="发表于 2023-10-31 00:00:00">2023-10-31</time></div></div></div></div></div></div></main><footer id="footer" style="background: #bbcdc5"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By 小鱼</div><div class="framework-info"><span>Frame- </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme- </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>